<html>
<body>

<div id="divUi">

	<h3>Civilization-Building Game</h3>

	<p>
		Enter valid commands to play the game.  Enter "help" for a list of commands.
	</p>

	<div>
		<label>Display:</label>
		<br />
		<div id="textareaDisplay" style="font:10px Courier New" readonly="readonly"></div>
	</div>

	<div>
		<label>Output:</label>
		<br />
		<div id="textareaOutputLog" style="font:10px Courier New" readonly="readonly"></div>
	</div>

	<div>
		<label>Command:</label>
		<br />
		<input id="inputCommand" readonly="readonly"></input>
	</div>

</div>

<script type="text/javascript">

class Game
{
	run()
	{
		var display = new Display("textareaDisplay");
		var world = World.demo();
		var universe = new Universe(display, world);
		universe.initialize();
	}
}

// Classes.

class Base
{
	constructor
	(
		name,
		pos,
		ownerName,
		population,
		landUsage,
		foodStockpiled,
		industry
	)
	{
		this.name = name;
		this.pos = pos;
		this.ownerName = ownerName;
		this.population = population;
		this.landUsage = landUsage;
		this.foodStockpiled = foodStockpiled;
		this.industry = industry;
	}

	turnUpdate(universe, world)
	{
		// todo
	}
}

class BaseImprovementDefn
{
	constructor(name, effect)
	{
		this.name = name;
		this.effect = effect;
	}
}

class BaseIndustry
{
	constructor(buildableInProgressName, industryStockpiled)
	{
		this.buildableInProgressName = buildableInProgressName;
		this.industryStockpiled = industryStockpiled;
	}
}

class BaseLandUsage
{
	constructor(offsetsInUse)
	{
		this.offsetsInUse = offsetsInUse;
	}
}

class Color
{
	constructor(name, systemColor)
	{
		this.name = name;
		this.systemColor = systemColor;
	}
}

class Command
{
	constructor(opcode, operands)
	{
		this.opcode = opcode;
		this.operands = operands;
	}

	static fromText(commandText)
	{
		var commandParsed = null;

		var opcode = CommandOpcode.fromCommandText(commandText);

		if (opcode != null)
		{
			var commandTextMinusOpcode = commandText.substr(opcode.text.length);
			var operands = commandTextMinusOpcode.split(" ").filter(x => x != "");

			commandParsed = new Command(opcode, operands);
		}

		return commandParsed;
	}

	execute(universe, world)
	{
		this.opcode.execute(universe, world, this);
	}
}

class CommandOpcode
{
	constructor(text, execute)
	{
		this.text = text;
		this.execute = execute;
	}

	static Instances()
	{
		if (CommandOpcode._instances == null)
		{
			CommandOpcode._instances = new CommandOpcode_Instances();
		}
		return CommandOpcode._instances;
	}

	static fromCommandText(commandText)
	{
		var opcode = CommandOpcode.Instances().byCommandText(commandText);
		return opcode;
	}
}

class CommandOpcode_Instances
{
	constructor()
	{
		var co = (text, execute) => new CommandOpcode(text, execute);

		var executeTodo = (u, w, c) => { u.display.writeLine("todo") };

		this.CityBuild = co("build", executeTodo);
		this.CityList = co("list cities", executeTodo);
		this.CitySelect = co("select city", executeTodo);
		this.CityShow = co("show city", executeTodo);
		this.CityUseLandAtOffset = co("use offset", executeTodo);

		this.CivList = co("list civilizations", executeTodo);
		this.CivSelect = co("select civilzation", executeTodo);
		this.CivShow = co("show civilization", executeTodo);

		this.CivOfferAccept = co("accept offer", executeTodo);
		this.CivOfferDecline = co("decline offer", executeTodo);
		this.CivOfferAlliance = co("alliance", executeTodo);
		this.CivOfferList = co("list offers", executeTodo);
		this.CivOfferPeace = co("peace", executeTodo);
		this.CivOfferTrade = co("trade", executeTodo);
		this.CivOfferWar = co("war", executeTodo);

		this.Help = co
		(
			"help",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();
				outputLog.writeLine("Commands Available:");
				CommandOpcode.Instances()._All.forEach
				(
					x => u.outputLog.writeLine(x.text)
				);
			}
		);

		// Tech.

		this.TechShow = co
		(
			"show research",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();
				var owner = w.ownerCurrent();
				outputLog.writeLine(owner.name + " Research:");
				var ownerResearch = owner.research;
				var ownerResearchAsString = ownerResearch.toString();
				outputLog.writeLine(ownerResearchAsString);
			}
		);

		this.TechList = co
		(
			"list techs",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();
				outputLog.writeLine("Technologies Available for Research:");
				var technologiesAvailable = [];
				technologiesAvailable.forEach
				(
					x => u.outputLog.writeLine(x.text)
				);
			}
		);

		this.TechResearch = co("research", executeTodo);

		this.TurnEnd = co("end turn", executeTodo);

		this.UnitDisband = co("disband", executeTodo);
		this.UnitFortify = co("fortify", executeTodo);
		this.UnitList = co("list units", executeTodo);
		this.UnitMove = co("move", executeTodo);
		this.UnitPass = co("pass", executeTodo);
		this.UnitSelect = co("select unit", executeTodo);
		this.UnitSleep = co("sleep", executeTodo);
		this.UnitSupport = co("support", executeTodo);

		this.UnitSettlerIrrigate = co("irrigate", executeTodo);
		this.UnitSettlerMine = co("mine", executeTodo);
		this.UnitSettlerRoad = co("road", executeTodo); 
		this.UnitSettlerSettle = co("settle", executeTodo);

		this.WorldShow = co
		(
			"show world",
			(u, w, c) =>
			{
				w.draw(u, w);
			}
		);

		this._All =
		[
			this.CityBuild,
			this.CityList,
			this.CitySelect,
			this.CityShow,
			this.CityUseLandAtOffset,

			this.CivOfferAccept,
			this.CivOfferDecline,
			this.CivOfferAlliance,
			this.CivOfferList,
			this.CivOfferPeace,
			this.CivOfferTrade,
			this.CivOfferWar,

			this.Help,

			this.TechShow,
			this.TechList,
			this.TechResearch,

			this.TurnEnd,

			this.UnitDisband,
			this.UnitFortify,
			this.UnitList,
			this.UnitMove,
			this.UnitPass,
			this.UnitSelect,
			this.UnitSleep,
			this.UnitSupport,

			this.UnitSettlerIrrigate,
			this.UnitSettlerMine,
			this.UnitSettlerRoad,
			this.UnitSettlerSettle,

			this.WorldShow,
		];
	}

	byCommandText(commandText)
	{
		var opcodeFound =
			this._All.find(x => commandText.startsWith(x.text));
		return opcodeFound;
	}
}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	static create()
	{
		return new Coords(0, 0);
	}

	static random()
	{
		return Coords.create().randomize();
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	floor()
	{
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	randomize()
	{
		this.x = Math.random();
		this.y = Math.random();
		return this;
	}
}

class Display
{
	constructor(domElementId)
	{
		this.domElementId = domElementId;
	}

	clear()
	{
		var d = document;
		var textareaDisplay = d.getElementById(this.domElementId);
		textareaDisplay.innerHTML = "";
	}

	clearAndWriteLine(lineToWrite)
	{
		this.clear();
		this.writeLine(lineToWrite);
	}

	writeLine(lineToWrite)
	{
		this.writeString(lineToWrite);
		this.writeNewline();
	}

	writeNewline()
	{
		this.writeString("<br />");
	}

	writeString(stringToWrite, colorName)
	{
		var d = document;
		var textareaDisplay = d.getElementById(this.domElementId);
		if (colorName != null)
		{
			stringToWrite = "<mark style='background-color:" + colorName + "'>" + stringToWrite + "</mark>";
		}
		textareaDisplay.innerHTML += stringToWrite;
	}
}

class IdHelper
{
	static _idNext = 0;

	static idNext()
	{
		var id = this._idNext;
		this._idNext++;
		return id;
	}
}

class InputHelper
{
	initialize(universe)
	{
		var d = document;

		var body = d.body;
		body.onkeydown = this.keyDown.bind(this, universe);

		var inputCommand = d.getElementById("inputCommand");
		inputCommand.focus();

		return this;
	}

	keyDown(universe, event)
	{
		event.preventDefault();

		var key = event.key;

		var d = document;
		var inputCommand = d.getElementById("inputCommand");

		if (key == "Enter")
		{
			var commandText = inputCommand.value;

			inputCommand.value = "";
			inputCommand.focus();

			var command = Command.fromText(commandText);
			if (command == null)
			{
				universe.outputLog.clearAndWriteLine("Unrecognized command: " + commandText);
			}
			else
			{
				command.execute(universe, universe.world);
			}
		}
		else if (key == "Backspace")
		{
			inputCommand.value = inputCommand.value.substr(0, inputCommand.value.length - 1);
		}
		else if (key.length == 1)
		{
			inputCommand.value += key;
		}
	}
}

class MapOfCells
{
	constructor(sizeInCells, cells)
	{
		this.sizeInCells = sizeInCells;
		this.cells = cells;
	}

	static fromCellsAsStrings(cellsAsStrings)
	{
		var sizeInCells = new Coords
		(
			cellsAsStrings[0].length, cellsAsStrings.length
		);
		var cells = [];

		var cellPosInCells = Coords.create();

		for (var y = 0; y < sizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < sizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cellAsString = cellsAsStrings[y][x];
				var cellTerrainCode = cellAsString;

				var cell = new MapOfCellsCell
				(
					cellTerrainCode
				);

				cells.push(cell);
			}
		}

		var map = new MapOfCells(sizeInCells, cells);

		return map;
	}

	cellAtPos(posInCells)
	{
		return this.cells[this.cellIndexAtPos(posInCells)];
	}

	cellIndexAtPos(posInCells)
	{
		return posInCells.y * this.sizeInCells.x + posInCells.x;
	}

	draw(universe, world)
	{
		var display = universe.display;
		var cellPosInCells = Coords.create();

		for (var y = 0; y < this.sizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < this.sizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cell = this.cellAtPos(cellPosInCells);
				var cellTerrain = cell.terrain(world);
				var cellTerrainSymbol = cellTerrain.symbol;
				var cellTerrainColorName = cellTerrain.colorName;

				var cellAsString = cellTerrainSymbol + cellTerrainSymbol;

				display.writeString(cellAsString, cellTerrainColorName);
			}

			display.writeNewline();
		}
	}
}

class MapOfCellsCell
{
	constructor
	(
		terrainCode,
		basesPresentNames,
		improvementsPresentNames,
		unitsPresentIds
	)
	{
		this.terrainCode = terrainCode;
		this.basesPresentNames = basesPresentNames || [];
		this.improvementsPresentNames = improvementsPresentNames || [];
		this.unitsPresentIds = unitsPresentIds || [];
	}

	baseAdd(base)
	{
		this.basesPresentNames.push(base.name);
	}

	terrain(world)
	{
		return world.defns.terrainByCode(this.terrainCode);
	}

	unitAdd(unit)
	{
		this.unitsPresentIds.push(unit.id);
	}
}

class MapOfCellsCellImprovement
{
	constructor(name, effect)
	{
		this.name = name;
		this.effect = effect;
	}
}

class MapOfCellsCellTerrain
{
	constructor
	(
		name,
		code,
		colorName,
		symbol,
		movesToTraverse,
		resourceProductionPerTurn
	)
	{
		this.name = name;
		this.code = code;
		this.colorName = colorName;
		this.symbol = symbol;
		this.movesToTraverse = movesToTraverse;
		this.resourceProductionPerTurn = resourceProductionPerTurn;
	}
}

class Owner
{
	constructor
	(
		name,
		colorName,
		incomeAllocation,
		research,
		mapKnowledge,
		bases,
		units
	)
	{
		this.name = name;
		this.colorName = colorName;
		this.incomeAllocation = incomeAllocation;
		this.research = research;
		this.mapKnowledge = mapKnowledge;
		this.bases = bases;
		this.units = units;
	}
}

class OwnerIncomeAllocation
{
	constructor(upkeepFraction, researchFraction, luxuriesFraction)
	{
		this.upkeepFraction = upkeepFraction;
		this.researchFraction = researchFraction;
		this.luxuriesFraction = luxuriesFraction;
	}

	static default()
	{
		return new OwnerIncomeAllocation(.5, .5, 0);
	}

	isValid()
	{
		var sumOfFractions =
			this.upkeepFraction
			+ this.researchFraction
			+ this.luxuriesFraction;

		return (sumOfFractions == 1);
	}
}

class OwnerMapKnowledge
{
	constructor(cellsKnownIndices)
	{
		this.cellsKnownIndices = cellsKnownIndices || [];
	}

	static default()
	{
		return new OwnerMapKnowledge(null);
	}

	mapKnownFromMapComplete(mapComplete)
	{
		return mapComplete; // todo
	}
}

class OwnerResearch
{
	constructor
	(
		technologiesKnownNames,
		technologyBeingResearchedName,
		researchStockpiled
	)
	{
		this.technologiesKnownNames = technologiesKnownNames || [];
		this.technologyBeingResearchedName = technologyBeingResearchedName;
		this.researchStockpiled = researchStockpiled || 0;
	}

	static default()
	{
		return new OwnerResearch(null, null, null);
	}
}

class ResourceProduction
{
	constructor(food, industry, trade)
	{
		this.food = food;
		this.industry = industry;
		this.trade = trade;
	}
}

class Technology
{
	constructor
	(
		name,
		researchToLearn,
		prerequisiteNames,
		unitDefnsAllowedNames
	)
	{
		this.name = name;
		this.researchToLearn = researchToLearn;
		this.prerequisiteNames = prerequisiteNames;
		this.unitDefnsAllowedNames = unitDefnsAllowedNames;
	}
}

class Unit
{
	constructor(ownerName, defnName, pos)
	{
		this.ownerName = ownerName;
		this.defnName = defnName;
		this.pos = pos;

		this.id = IdHelper.idNext();
		this.isSleeping = false;
	}

	defn(world)
	{
		return world.defns.unitDefnByName(this.defnName);
	}

	move(world, directionToMove)
	{
		var map = world.map;
		var cellFromPos = this.pos;
		var cellToPos = cellPos.add(directionToMove);

		var cellFrom = map.cellAtPos(cellPosNext);
		var cellTo = map.cellAtPos(cellPosNext);

		var cellNextTerrain = cellNext.terrain(world);
		var defn = this.defn(world);

		var costToMove = defn.costToMoveFromCellToCell
		(
			world, cellFrom, cellTo
		);

		if (costToMove <= this.movesThisTurn)
		{
			this.movesThisTurn -= costToMove;
			this.pos.overwriteWith(cellToPos);
		}
	}

	turnUpdate()
	{
		var defn = this.defn();
		this.movesThisTurn = defn.movesPerTurn;
	}
}

class UnitActivity
{
	constructor(defnName, movesInvestedSoFar)
	{
		this.defnName = defnName;
		this.movesInvestedSoFar = movesInvestedSoFar;
	}
}

class UnitActivityDefn
{
	constructor(name, movesToComplete, effect)
	{
		this.name = name;
		this.movesToComplete = movesToComplete;
		this.effect = effect;
	}
}

class UnitDefn
{
	constructor
	(
		name,
		industryToBuild,
		movement,
		combat,
		activityDefnsAvailableNames,
		symbol
	)
	{
		this.name = name;
		this.industryToBuild = industryToBuild;
		this.movement = movement;
		this.combat = combat;
		this.activityDefnsAvailableNames = activityDefnsAvailableNames;
		this.symbol = symbol;
	}

	static Instances()
	{
		if (Unit._instances == null)
		{
			Unit._instances = new Unit_Instances();
		}
		return Unit._instances;
	}
}

class UnitDefn_Instances
{
	constructor()
	{
		// Movements
		var g1 = UnitDefnMovement.ground1();
		var g2 = UnitDefnMovement.ground(2);
		var o1 = UnitDefnMovement.ocean1();
		var o5 = UnitDefnMovement.ocean(5);

		var a0 = [];
		var ud = new UnitDefn;
		var c = new UnitDefnCombat; // attack, defense, integrityMax
		var udTodo =
			() =>
			{
				return new UnitDefn
				(
					"[todo]", 1000, c(0, 0, 1), UnitDefnMovement.ground(1), null, "?"
				);
			};

		// Taken from https://civilization.fandom.com/wiki/List_of_units_in_Civ2.
		// 						name,				cost,	move, 	combat, 	actns, 	symbol
		this.AegisCruiser	= udTodo();
		this.AlpineTroops	= udTodo();
		this.Archers 		= ud("Archers", 		30, 	g1,		c(3,2,1), 	a0, 	"Arc");
		this.Armor			= udTodo();
		this.Artillery		= udTodo();
		this.Battleship		= udTodo();
		this.Bomber			= udTodo();
		this.Cannon			= ud("Cannon", 			40,		g1,		c(8,1,2),	a0,		"Can");
		this.Caravan		= ud("Caravan",			50,		g1,		c(0,1,1),	a0,		"Car");
		this.Carrier		= udTodo();
		this.Catapult		= ud("Catapult",		40,		g1,		c(6,1,1),	a0,		"Cat");
		this.Cavalry		= udTodo();
		this.Chariot		= ud("Chariot",			30,		g1,		c(3,1,1),	a0, 	"Cha");
		this.CruiseMissile	= udTodo();
		this.Cruiser		= udTodo();
		this.Crusaders		= udTodo();
		this.Destroyer		= udTodo();
		this.Diplomat		= ud("Diplomat", 		30,		g1,		c(0,1,1),	a0,		"Dip");
		this.Dragoons		= udTodo();
		this.Elephants		= udTodo();
		this.Engineers		= udTodo();
		this.Explorer		= udTodo();
		this.Fanatics		= udTodo();
		this.Fighter		= udTodo();
		this.Freight		= udTodo();
		this.Frigate		= udTodo();
		this.Galleon		= udTodo();
		this.Helicopter		= udTodo();
		this.Horsemen		= udTodo();
		this.Howitzer		= udTodo();
		this.Ironclad		= udTodo();
		this.Knights		= ud("Knights", 		40, 	g2, 	c(2,1,1), 	a0,		"Kni");
		this.Legion			= ud("Legion", 			40,		g1,		c(4,2,1),	a0,		"Leg");
		this.Marines		= udTodo();
		this.MechInfantry	= udTodo();
		this.Musketeers		= udTodo();
		this.NuclearMissile	= udTodo();
		this.Paratroopers	= udTodo();
		this.Partisans		= udTodo();
		this.Phalanx		= ud("Phalanx",			20,		g1,		c(1,2,1),	a0,		"Pha");
		this.Pikemen		= ud("Pikemen",			20,		g1,		c(1,2,1),	a0,		"Pik");
		this.Riflemen		= ud("Riflemen",		40,		g1,		c(4,2,1),	a0,		"Rif");
		this.Settlers 		= ud("Settlers", 		40, 	g1, 	c(0,1,2),	a0,		"Set");
		this.Spy			= ud("Spy", 			30,		g3,		c(0,0,1),	a0,		"Spy");
		this.StealthBomber	= udTodo();
		this.StealthFighter	= udTodo();
		this.Submarine		= udTodo();
		this.Transport		= udTodo();
		this.Trireme		= ud("Trireme",			40,		o3,		c(1,1,1),	a0,		"Tri");
		this.Warriors 		= ud("Warriors", 		10, 	g1, 	c(1,1,1),	a0,		"War");

		this._All =
		[
			this.AegisCruiser,
			this.Battleship,
			this.Bomber,
			this.Cannon,
			this.Caravan,
			this.Carrier,
			this.Catapult,
			this.Cavalry,
			this.Chariot,
			this.CruiseMissile,
			this.Cruiser,
			this.Crusaders,
			this.Destroyer,
			this.Diplomat,
			this.Dragoons,
			this.Elephants,
			this.Engineers,
			this.Explorer,
			this.Fanatics,
			this.Fighter,
			this.Freight,
			this.Frigate,
			this.Galleon,
			this.Helicopter,
			this.Horsemen,
			this.Howitzer,
			this.Ironclad,
			this.Knights,
			this.Legion,
			this.Marines,
			this.MechInfantry,
			this.Musketeers,
			this.NuclearMissile,
			this.Paratroopers,
			this.Partisans,
			this.Phalanx,
			this.Pikemen,
			this.Riflemen,
			this.Settlers,
			this.Spy,
			this.StealthFighter,
			this.Submarine,
			this.Transport,
			this.Trireme,
			this.Warriors
		];
	}
}

class UnitDefnCombat
{
	constructor(attack, defense, integrityMax)
	{
		this.attack = attack;
		this.defense = defense;
		this.integrityMax = integrityMax;
	}
}

class UnitDefnMovement
{
	constructor(movesPerTurn, costToMoveFromCellToCell)
	{
		this.movesPerTurn = movesPerTurn;
		this.costToMoveFromCellToCell = costToMoveFromCellToCell;
	}

	static ground1()
	{
		return new UnitDefnMovement
		(
			1, // movesPerTurn
			(universe, world, cellFrom, cellTo) =>
			{
				var cellToTerrain = cellTo.terrain(world);
				var cellToTerrainIsGround = cellToTerrain.isGround();
				var costToMove =
				(
					cellToTerrainIsGround
					? cellTerrain.movesToTraverse
					: Number.POSITIVE_INFINITY
				);
				return costToMove;
			}
		);
	}

	static ocean1()
	{
		return new UnitDefnMovement
		(
			1, // movesPerTurn
			(universe, world, cellFrom, cellTo) =>
			{
				var cellToTerrain = cellTo.terrain(world);
				var cellToTerrainIsGround = cellToTerrain.name == "Ocean";
				var costToMove = (cellToTerrainIsGround ? 1 : Number.POSITIVE_INFINITY);
				return costToMove;
			}
		);
	}

}

class Universe
{
	constructor(display, world)
	{
		this.display = display;
		this.world = world;

		this.inputHelper = new InputHelper();
		this.outputLog = new Display("textareaOutputLog");
	}

	initialize()
	{
		this.inputHelper.initialize(this);
	}
}

class World
{
	constructor(name, defns, turnsSoFar, map, owners)
	{
		this.name = name;
		this.defns = defns;
		this.turnsSoFar = turnsSoFar;
		this.map = map;
		this.owners = owners;

		this.bases = [];
		this.units = [];

		for (var i = 0; i < this.owners.length; i++)
		{
			var owner = this.owners[i];
			owner.bases.forEach(x => this.baseAdd(x));
			owner.units.forEach(x => this.unitAdd(x));
		}

		this.ownerCurrentIndex = 0;
	}

	static demo()
	{
		var terrains =
		[
			new MapOfCellsCellTerrain
			(
				"Ocean",
				"~", // code,
				"Blue", // colorName,
				"~", // symbol,
				100, // movesToTraverse,
				null // resourceProductionPerTurn
			),

			new MapOfCellsCellTerrain
			(
				"Plain",
				".", // code,
				"Green", // colorName,
				".", // symbol,
				1, // movesToTraverse,
				null // resourceProductionPerTurn
			),
		];

		var unitDefns =
		[
			new UnitDefn
			(
				"Settlers",
				50, // industryToBuild,
				0, // attack,
				1, // defense,
				UnitDefnMovement.ground1(),
				null // activityDefnsAvailableNames
			)
		];

		var defns = new WorldDefns
		(
			terrains,
			unitDefns
		);

		var map = MapOfCells.fromCellsAsStrings
		([
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~..............................................................~",
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
		]);

		var owners = [];
		var ownerCount = 2;
		var ownerColorNames = [ "Blue", "Green" ];

		for (var i = 0; i < ownerCount; i++)
		{
			var ownerName = "Owner" + i;
			var ownerColorName = ownerColorNames[i];

			var posRandom = Coords.random().multiply(map.sizeInCells).floor();
			var unitInitial = new Unit
			(
				ownerName,
				"Settler",
				posRandom
			);

			var owner = new Owner
			(
				ownerName,
				ownerColorName,
				OwnerIncomeAllocation.default(), // incomeAllocation,
				OwnerResearch.default(),
				OwnerMapKnowledge.default(),
				[], // bases
				[
					unitInitial
				]
			);

			owners.push(owner);
		}

		var worldDemo = new World
		(
			"Demo World:",
			defns,
			0, // turnsSoFar
			map,
			owners
		);

		return worldDemo;
	}

	draw(universe, world)
	{
		var display = universe.display;
		display.writeLine(this.name);
		this.map.draw(universe, world);
		display.writeNewline();
	}

	baseAdd(base)
	{
		this.bases.push(base);
		var cell = this.map.cellAtPos(base.pos);
		cell.baseAdd(cell);
	}

	ownerByName(name)
	{
		return this.owners.find(x => x.name == name);
	}

	ownerCurrent()
	{
		return this.owners[this.ownerCurrentIndex];
	}

	ownerCurrentAdvance()
	{
		this.ownerCurrentIndex++;
		if (this.ownerCurrentIndex >= this.owners.length)
		{
			this.ownerCurrentIndex = 0;
		}

		return this.ownerCurrent();
	}

	unitAdd(unit)
	{
		this.units.push(unit);
		var cell = this.map.cellAtPos(unit.pos);
		cell.unitAdd(unit);
	}

	unitById(id)
	{
		return this.units.find(x => x.id == id);
	}
}

class WorldDefns
{
	constructor(terrains, unitDefns)
	{
		this.terrains = terrains;
		this.unitDefns = unitDefns;

		this._terrainsByCode = new Map(this.terrains.map(x => [x.code, x]));
		this._unitDefnsByName = new Map(this.unitDefns.map(x => [x.name, x]));
	}

	terrainByCode(code)
	{
		return this._terrainsByCode.get(code);
	}

	unitDefnByName(name)
	{
		return this._unitDefnsByName.get(name);
	}
}

// Run.

new Game().run();

</script>

</body>
</html>