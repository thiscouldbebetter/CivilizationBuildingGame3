<html>
<body>

<div id="divUi">

	<h3>Civilization-Building Game</h3>

	<p>
		Enter valid commands to play the game.  Enter "help" for a list of commands.
	</p>

	<div>
		<label>Display:</label>
		<br />
		<div id="divDisplay" style="border:1px solid"></div>
	</div>

	<div>
		<label>Output:</label>
		<br />
		<div id="textareaOutputLog" style="font:10px Courier New" readonly="readonly"></div>
	</div>

	<div>
		<label>Command:</label>
		<br />
		<input id="inputCommand" readonly="readonly"></input>
	</div>

</div>

<script type="text/javascript">

class Game
{
	run()
	{
		var display = new DisplayCanvas
		(
			"divDisplay", new Coords(1024, 512)
		);
		var world = World.demo();
		var universe = new Universe(display, world);
		universe.initialize();
	}
}

// Classes.

class Base
{
	constructor
	(
		name,
		pos,
		ownerName,
		population,
		landUsage,
		foodStockpiled,
		industry
	)
	{
		this.name = name;
		this.pos = pos;
		this.ownerName = ownerName;
		this.population = population;
		this.landUsage = landUsage;
		this.foodStockpiled = foodStockpiled;
		this.industry = industry;
	}

	initialize(world)
	{
		// todo
	}

	toStringDetails(world)
	{
		var defn = this.defn(world);

		var lines =
		[
			"Name: " + this.id,
			"Onwer:" + this.ownerName,
			"Position: " + this.pos.toString(),
			"Population: " + this.population,
			"Food: " + this.foodStockpiled,
			this.landUsage.toString(),
			this.industry.toString()
		];

		var linesJoined = lines.join("<br />");

		return linesJoined;
	}

	toStringForList()
	{
		return this.name + " @" + this.pos.toString();
	}

	turnAdvance(world)
	{
		this.landUsage.turnAdvance(world, this);
		this.industry.turnAdvance(world, this);
	}
}

class BaseImprovementDefn
{
	constructor(name, effect)
	{
		this.name = name;
		this.effect = effect;
	}
}

class BaseIndustry
{
	constructor(buildableInProgressName, industryStockpiled)
	{
		this.buildableInProgressName = buildableInProgressName;
		this.industryStockpiled = industryStockpiled;
	}

	toString()
	{
		var returnValue =
			"Building: "
			+ this.buildableInProgressName
			+ this.industryStockpiled
			+ "/?"; // todo

		return returnValue;
	}

	turnAdvance(world, base)
	{
		// todo
	}
}

class BaseLandUsage
{
	constructor(offsetsInUse)
	{
		this.offsetsInUse = offsetsInUse;
	}

	toString()
	{
		return "Land Usage: " + this.offsetsInUse.map(x => x.toString()).join(";");
	}

	turnAdvance(world, base)
	{
		var basePos = base.pos;
		var cellsInUsePositions =
			this.offsetsInUse.map(x => x.clone().add(basePos));
		var map = world.map();
		var cellsInUse =
			cellsInUsePositions.map(x => map.cellAtPosInCells(x) );
		var resourcesProducedByCells =
			cellsInUse.map(x => x.resourcesProduced(world, base) );
		var resourcesProducedByBase =
			ResourceProduction.create();
		resourcesProducedByCells.forEach(x => resourcesProducedByBase.add(x) );
		// todo
	}
}

class Color
{
	constructor(name, systemColor)
	{
		this.name = name;
		this.systemColor = systemColor;
	}
}

class Command
{
	constructor(opcode, operands)
	{
		this.opcode = opcode;
		this.operands = operands;
	}

	static fromText(commandText)
	{
		var commandParsed = null;

		var opcode = CommandOpcode.fromCommandText(commandText);

		if (opcode != null)
		{
			var commandTextMinusOpcode = commandText.substr(opcode.text.length);
			var operands = commandTextMinusOpcode.split(" ").filter(x => x != "");

			commandParsed = new Command(opcode, operands);
		}

		return commandParsed;
	}

	execute(universe, world)
	{
		this.opcode.execute(universe, world, this);
	}
}

class CommandOpcode
{
	constructor(text, execute)
	{
		this.text = text;
		this.execute = execute;
	}

	static Instances()
	{
		if (CommandOpcode._instances == null)
		{
			CommandOpcode._instances = new CommandOpcode_Instances();
		}
		return CommandOpcode._instances;
	}

	static fromCommandText(commandText)
	{
		var opcode = CommandOpcode.Instances().byCommandText(commandText);
		return opcode;
	}
}

class CommandOpcode_Instances
{
	constructor()
	{
		var co = (text, execute) => new CommandOpcode(text, execute);

		var executeTodo = (u, w, c) => { alert("todo") };

		this.CityBuild = co("build", executeTodo);
		this.CityList = co
		(
			"list cities",
			(u, w, c) =>
			{
				var owner = w.ownerCurrent();
				var bases = owner.bases;

				var outputLog = u.outputLog;
				outputLog.clear();
				bases.forEach(x => outputLog.writeLine( x.toStringForList() ) );
			}

		);
		this.CitySelect = co("select city", executeTodo);
		this.CityShow = co("show city", executeTodo);
		this.CityUseLandAtOffset = co("use offset", executeTodo);

		this.CivList = co("list civilizations", executeTodo);
		this.CivSelect = co("select civilzation", executeTodo);
		this.CivShow = co("show civilization", executeTodo);

		this.CivOfferAccept = co("accept offer", executeTodo);
		this.CivOfferDecline = co("decline offer", executeTodo);
		this.CivOfferAlliance = co("alliance", executeTodo);
		this.CivOfferList = co("list offers", executeTodo);
		this.CivOfferPeace = co("peace", executeTodo);
		this.CivOfferTrade = co("trade", executeTodo);
		this.CivOfferWar = co("war", executeTodo);

		this.Help = co
		(
			"help",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();
				outputLog.writeLine("Commands Available:");
				CommandOpcode.Instances()._All.forEach
				(
					x => u.outputLog.writeLine(x.text)
				);
			}
		);

		// Tech.

		this.TechShow = co
		(
			"show research",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();
				var owner = w.ownerCurrent();
				outputLog.writeLine(owner.name + " Research:");
				var ownerResearch = owner.research;
				var ownerResearchAsString = ownerResearch.toString();
				outputLog.writeLine(ownerResearchAsString);
			}
		);

		this.TechList = co
		(
			"list techs",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();
				outputLog.writeLine("Technologies Available for Research:");
				var technologiesAvailable = [];
				technologiesAvailable.forEach
				(
					x => u.outputLog.writeLine(x.text)
				);
			}
		);

		this.TechResearch = co("research", executeTodo);

		this.TurnEnd = co
		(
			"end turn",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();
				w.turnAdvance(u);
				outputLog.writeLine("Next turn:" + w.turnsSoFar);
			}
		);

		// Units.

		this.UnitActionsShow = co
		(
			"list actions",
			(u, w, c) =>
			{
				var owner = w.ownerCurrent();
				var unit = owner.unitSelected();
				var unitDefn = unit.defn(w);

				var outputLog = u.outputLog;
				outputLog.clear();
				outputLog.writeLine("Actions available:");
				var actionsAvailableNames = unitDefn.actionsAvailableNames;
				actionsAvailableNames.forEach
				(
					x => outputLog.writeLine(x)
				);
			}
		)
		this.UnitDisband = co("disband", executeTodo);
		this.UnitFortify = co("fortify", executeTodo);

		this.UnitList = co
		(
			"list units",
			(u, w, c) =>
			{
				var owner = w.ownerCurrent();
				var units = owner.units;

				var outputLog = u.outputLog;
				outputLog.clear();
				units.forEach(x => outputLog.writeLine( x.toStringForList() ) );
			}
		);

		this.UnitMove = co
		(
			"move",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();

				var ownerCurrent = w.ownerCurrent();
				var unitSelected = ownerCurrent.unitSelected();
				if (unitSelected == null)
				{
					outputLog.writeLine("No unit selected!");
				}
				else if (unitSelected.hasMovesThisTurn() == false)
				{
					outputLog.writeLine("Unit " + unitSelected.id + " has no moves left!");
				}
				else
				{
					var directionToMoveCode = c.operands[0];
					var directionToMove = Direction.byCode(directionToMoveCode);
					var message = null;
					if (directionToMove == null)
					{
						message = "Invalid direction: " + directionToMoveCode;
					}
					else
					{
						var canMove =
							unitSelected.canMoveInDirection(directionToMove, w);

						if (canMove)
						{
							unitSelected.moveInDirection(directionToMove, w);
							message =
								"Unit " + unitSelected.id + " moved "
								+ directionToMove.name.toLowerCase() + ".";
							outputLog.writeLine(message);

							if (unitSelected.hasMovesThisTurn() == false)
							{
								message =
									"Unit " + unitSelected.id + " out of moves this turn.";
								outputLog.writeLine(message);

								ownerCurrent.unitSelectNextWithMoves();
								unitSelected = ownerCurrent.unitSelected();

								if (unitSelected == null)
								{
									message =
										"No more units with moves this turn."
										+ "  Enter 'end turn' to end the turn.";
									outputLog.writeLine(message);
								}
								else
								{
									message = "Selected next unit with moves: " + unitSelected.id + "."
									outputLog.writeLine(message);
								}
							}
						}
						else
						{
							message =
								"Unit " + unitSelected.id + " cannot move "
								+ directionToMove.name.toLowerCase() + ".";
							outputLog.writeLine(message);
						}
					}
				}
			}
		);

		this.UnitPass = co("pass", executeTodo);

		this.UnitSelect = co
		(
			"select unit",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();

				var owner = w.ownerCurrent();
				var operand0 = c.operands[0];
				try
				{
					var idToSelect = null;

					if (operand0 == "next")
					{
						owner.unitSelectNextWithMoves();
						var unitSelected = owner.unitSelected();
						if (unitSelected != null)
						{
							idToSelect = unitSelected.id;
						}
					}
					else
					{
						idToSelect = parseInt(operand0);
						owner.unitSelectById(idToSelect);
					}
					outputLog.writeLine("Selected unit " + idToSelect + ".");
				}
				catch (err)
				{
					outputLog.writeLine(err.message);
				}
			}
		);

		this.UnitShow = co
		(
			"show unit",
			(u, w, c) =>
			{
				var outputLog = u.outputLog;
				outputLog.clear();

				var unitSelected = w.ownerCurrent().unitSelected();
				if (unitSelected == null)
				{
					outputLog.writeLine("No unit selected!");
				}
				else
				{
					var unitDetails = unitSelected.toStringDetails(w);
					outputLog.writeLine(unitDetails);
				}
			}
		);

		this.UnitSleep = co("sleep", executeTodo);
		this.UnitSupport = co("support", executeTodo);

		this.UnitSettlerIrrigate = co("irrigate", executeTodo);
		this.UnitSettlerMine = co("mine", executeTodo);
		this.UnitSettlerRoad = co("road", executeTodo); 
		this.UnitSettlerSettle = co("settle", executeTodo);

		this.WorldShow = co
		(
			"show world",
			(u, w, c) =>
			{
				w.draw(u, w);
				var outputLog = u.outputLog;
				outputLog.clear();
				var worldDetails = "Turn: " + w.turnsSoFar;
				outputLog.writeLine(worldDetails);
			}
		);

		this._All =
		[
			this.CityBuild,
			this.CityList,
			this.CitySelect,
			this.CityShow,
			this.CityUseLandAtOffset,

			this.CivOfferAccept,
			this.CivOfferDecline,
			this.CivOfferAlliance,
			this.CivOfferList,
			this.CivOfferPeace,
			this.CivOfferTrade,
			this.CivOfferWar,

			this.Help,

			this.TechShow,
			this.TechList,
			this.TechResearch,

			this.TurnEnd,

			this.UnitDisband,
			this.UnitFortify,
			this.UnitList,
			this.UnitMove,
			this.UnitPass,
			this.UnitSelect,
			this.UnitShow,
			this.UnitSleep,
			this.UnitSupport,

			this.UnitSettlerIrrigate,
			this.UnitSettlerMine,
			this.UnitSettlerRoad,
			this.UnitSettlerSettle,

			this.WorldShow,
		];
	}

	byCommandText(commandText)
	{
		var opcodeFound =
			this._All.find(x => commandText.startsWith(x.text));
		return opcodeFound;
	}
}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	static create()
	{
		return new Coords(0, 0);
	}

	static ones()
	{
		return new Coords(1, 1);
	}

	static random()
	{
		return Coords.create().randomize();
	}

	static zeroes()
	{
		return new Coords(0, 0);
	}

	add(other)
	{
		this.x += other.x;
		this.y += other.y;
		return this;
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	divideScalar(scalar)
	{
		this.x /= scalar;
		this.y /= scalar;
		return this;
	}

	floor()
	{
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}

	half()
	{
		return this.divideScalar(2);
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	multiplyScalar(scalar)
	{
		this.x *= scalar;
		this.y *= scalar;
		return this;
	}

	overwriteWith(other)
	{
		this.x = other.x;
		this.y = other.y;
		return this;
	}

	overwriteWithXY(x, y)
	{
		this.x = x;
		this.y = y;
		return this;
	}

	randomize()
	{
		this.x = Math.random();
		this.y = Math.random();
		return this;
	}

	subtract(other)
	{
		this.x -= other.x;
		this.y -= other.y;
		return this;
	}

	toString()
	{
		return this.x + "," + this.y;
	}

	wrapXTrimYToMax(max)
	{
		while (this.x < 0)
		{
			this.x += max.x;
		}
		while (this.x >= max.x)
		{
			this.x -= max.x;
		}

		if (this.y < 0)
		{
			this.y = 0;
		}
		else if (this.y > max.y)
		{
			this.y = max.y - 1; // hack
		}

		return this;
	}
}

class Direction
{
	constructor(name, code, offset)
	{
		this.name = name;
		this.code = code;
		this.offset = offset;
	}

	static Instances()
	{
		if (Direction._instances == null)
		{
			Direction._instances = new Direction_Instances();
		}
		return Direction._instances;
	}

	static byCode(code)
	{
		return Direction.Instances().byCode(code);
	}
}

class Direction_Instances
{
	constructor()
	{
		this.East = new Direction("East", "e", new Coords(1, 0) );
		this.North = new Direction("North", "n", new Coords(0, -1) );
		this.Northeast = new Direction("Northeast", "ne", new Coords(1, -1) );
		this.Northwest = new Direction("Northwest", "nw", new Coords(-1, -1) );
		this.South = new Direction("South", "s", new Coords(0, 1) );
		this.Southeast = new Direction("Southeast", "se", new Coords(1, 1) );
		this.Southwest = new Direction("Southwest", "sw", new Coords(-1, 1) );
		this.West = new Direction("West", "w", new Coords(-1, 0) );

		this._All =
		[
			this.East,
			this.Southeast,
			this.South,
			this.Southwest,
			this.West,
			this.Northwest,
			this.North,
			this.Northeast
		];

		this._AllByCode = new Map(this._All.map(x => [x.code, x] ) );
	}

	byCode(code)
	{
		return this._AllByCode.get(code);
	}
}


class DisplayCanvas
{
	constructor(domElementParentId, sizeInPixels)
	{
		this.domElementParentId = domElementParentId;
		this.sizeInPixels = sizeInPixels;

		this.fontHeightInPixels = 10;
		this.fontHeightInPixelsHalf = this.fontHeightInPixels / 2;
		this.font = this.fontHeightInPixels + "px sans-serif";

		this._zeroes = Coords.zeroes();

		this.colorForegroundName = "Blue";
		this.colorBackgroundName = "Black";
	}

	clear()
	{
		this.graphics.clearRect(this.sizeInPixels);
	}

	initialize(universe)
	{
		var d = document;
		var canvas = d.createElement("canvas");
		canvas.width = this.sizeInPixels.x;
		canvas.height = this.sizeInPixels.y;

		var domElementParent = d.getElementById(this.domElementParentId);
		domElementParent.appendChild(canvas);

		this.graphics = canvas.getContext("2d");

		var divParent
	}

	// Draw.

	drawBackground(colorName)
	{
		this.drawRectangle
		(
			this._zeroes, this.sizeInPixels, colorName, null
		);
	}

	drawCircle(center, radius, colorFillName, colorBorderName)
	{
		this.graphics.beginPath();
		this.graphics.arc(center.x, center.y, radius, 0, Math.PI * 2);

		if (colorFillName != null)
		{
			this.graphics.fillStyle = colorFillName;
			this.graphics.fill();
		}

		if (colorBorderName != null)
		{
			this.graphics.strokeStyle = colorBorderName;
			this.graphics.stroke();
		}
	}

	drawRectangle(pos, size, colorFillName, colorBorderName)
	{
		if (colorFillName != null)
		{
			this.graphics.fillStyle = colorFillName;
			this.graphics.fillRect(pos.x, pos.y, size.x, size.y);
		}

		if (colorBorderName != null)
		{
			this.graphics.strokeStyle = colorBorderName;
			this.graphics.strokeRect(pos.x, pos.y, size.x, size.y);
		}
	}

	drawText(textToDraw, pos, colorName)
	{
		var textWidth = this.graphics.measureText(textToDraw).width;
		this.graphics.fillStyle = colorName;
		this.graphics.fillText
		(
			textToDraw,
			pos.x - textWidth / 2,
			pos.y + this.fontHeightInPixelsHalf
		);
	}

}

class DisplayText
{
	constructor(domElementId)
	{
		this.domElementId = domElementId;
	}

	clear()
	{
		var d = document;
		var textareaDisplay = d.getElementById(this.domElementId);
		textareaDisplay.innerHTML = "";
	}

	clearAndWriteLine(lineToWrite)
	{
		this.clear();
		this.writeLine(lineToWrite);
	}

	writeLine(lineToWrite)
	{
		this.writeString(lineToWrite);
		this.writeNewline();
	}

	writeNewline()
	{
		this.writeString("<br />");
	}

	writeString(stringToWrite, colorName)
	{
		var d = document;
		var textareaDisplay = d.getElementById(this.domElementId);
		if (colorName != null)
		{
			stringToWrite = "<mark style='background-color:" + colorName + "'>" + stringToWrite + "</mark>";
		}
		textareaDisplay.innerHTML += stringToWrite;
	}
}

class IdHelper
{
	static _idNext = 0;

	static idNext()
	{
		var id = this._idNext;
		this._idNext++;
		return id;
	}
}

class InputHelper
{
	initialize(universe)
	{
		var d = document;

		var body = d.body;
		body.onkeydown = this.keyDown.bind(this, universe);

		var inputCommand = d.getElementById("inputCommand");
		inputCommand.focus();

		return this;
	}

	keyDown(universe, event)
	{
		event.preventDefault();

		var key = event.key;

		var d = document;
		var inputCommand = d.getElementById("inputCommand");

		if (key == "Enter")
		{
			var commandText = inputCommand.value;

			inputCommand.value = "";
			inputCommand.focus();

			var command = Command.fromText(commandText);
			if (command == null)
			{
				universe.outputLog.clearAndWriteLine("Unrecognized command: " + commandText);
			}
			else
			{
				var world = universe.world;
				command.execute(universe, world);
				universe.world.draw(universe);
			}
		}
		else if (key == "Backspace")
		{
			inputCommand.value = inputCommand.value.substr(0, inputCommand.value.length - 1);
		}
		else if (key.length == 1)
		{
			inputCommand.value += key;
		}
	}
}

class MapOfCells
{
	constructor(sizeInCells, cells)
	{
		this.sizeInCells = sizeInCells;
		this.cells = cells;
	}

	static fromCellsAsStrings(cellsAsStrings)
	{
		var sizeInCells = new Coords
		(
			cellsAsStrings[0].length, cellsAsStrings.length
		);
		var cells = [];

		var cellPosInCells = Coords.create();

		for (var y = 0; y < sizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < sizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cellAsString = cellsAsStrings[y][x];
				var cellTerrainCode = cellAsString;

				var cell = new MapOfCellsCell
				(
					cellPosInCells.clone(),
					cellTerrainCode
				);

				cells.push(cell);
			}
		}

		var map = new MapOfCells(sizeInCells, cells);

		return map;
	}

	cellAtPosInCells(posInCells)
	{
		return this.cells[this.cellIndexAtPos(posInCells)];
	}

	cellIndexAtPos(posInCells)
	{
		return posInCells.y * this.sizeInCells.x + posInCells.x;
	}

	draw(universe, world)
	{
		var display = universe.display;
		var cellPosInCells = Coords.create();
		var cellSizeInPixels = Coords.ones().multiplyScalar(16); // hack
		var cellPosInPixels = Coords.create();

		for (var y = 0; y < this.sizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < this.sizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				cellPosInPixels.overwriteWith(cellPosInCells).multiply(cellSizeInPixels);

				var cell = this.cellAtPosInCells(cellPosInCells);
				var cellTerrain = cell.terrain(world);
				var cellTerrainSymbol = cellTerrain.symbol;
				var cellTerrainColorName = cellTerrain.colorName;

				display.drawRectangle
				(
					cellPosInPixels, cellSizeInPixels, cellTerrainColorName, "Gray"
				);
			}
		}
	}
}

class MapOfCellsCell
{
	constructor
	(
		pos,
		terrainCode,
		basePresentName,
		improvementsPresentNames,
		unitsPresentIds
	)
	{
		this.pos = pos;
		this.terrainCode = terrainCode;
		this.basePresentName = basePresentName;
		this.improvementsPresentNames = improvementsPresentNames || [];
		this.unitsPresentIds = unitsPresentIds || [];

		this._resourcesProducedThisTurn = ResourceProduction.create();
	}

	baseAdd(base)
	{
		this.basesPresentNames.push(base.name);
	}

	basePresent(world)
	{
		return (this.basePresentName == null ? null : world.baseByName(this.basePresentName));
	}

	resourcesProduced(world, base)
	{
		var terrain = this.terrain(world);
		var resources = this._resourcesProducedThisTurn.overwriteWith
		(
			terrain.resourceProductionPerTurn
		);
		// todo - Apply improvements, bonuses, penalties.
		return resources;
	}

	terrain(world)
	{
		return world.defns.terrainByCode(this.terrainCode);
	}

	unitAdd(unit)
	{
		this.unitsPresentIds.push(unit.id);
	}

	unitRemove(unit)
	{
		this.unitsPresentIds.splice(this.unitsPresentIds.indexOf(unit.id), 1);
	}

	unitsPresent(world)
	{
		return (this.unitsPresentIds.map(x => world.unitById(x)));
	}

}

class MapOfCellsCellImprovement
{
	constructor(name, code, effect)
	{
		this.name = name;
		this.code = code;
		this.effect = effect;
	}

	static Instances()
	{
		if (MapOfCellsCellImprovement._instances == null)
		{
			MapOfCellsCellImprovement._instances =
				new MapOfCellsCellImprovement_Instances();
		}
		return MapOfCellsCellImprovement._instances;
	}
}

class MapOfCellsCellImprovement_Instances
{
	constructor()
	{
		var effectTodo = "";

		this.Irrigation = new MapOfCellsCellImprovement("Irrigation", "i", effectTodo);
		this.Mine = new MapOfCellsCellImprovement("Mine", "m", effectTodo);
		this.Railroads = new MapOfCellsCellImprovement("Railroads", "R", effectTodo);
		this.Roads = new MapOfCellsCellImprovement("Roads", "r", effectTodo);
	}
}

class MapOfCellsCellTerrain
{
	constructor
	(
		name,
		categoryName,
		code,
		colorName,
		symbol,
		movesToTraverse,
		resourceProductionPerTurn
	)
	{
		this.name = name;
		this.categoryName = categoryName;
		this.code = code;
		this.colorName = colorName;
		this.symbol = symbol;
		this.movesToTraverse = movesToTraverse;
		this.resourceProductionPerTurn = resourceProductionPerTurn;
	}

	static Instances()
	{
		if (MapOfCellsCellTerrain._instances == null)
		{
			MapOfCellsCellTerrain._instances =
				new MapOfCellsCellTerrain_Instances();
		}
		return MapOfCellsCellTerrain._instances;
	}

	isLand()
	{
		return (this.categoryName == "Land");
	}
}

class MapOfCellsCellTerrain_Instances
{
	constructor()
	{
		var t = (a, b, c, d, e, f, g) =>
		{
			return new MapOfCellsCellTerrain(a, b, c, d, e, f, g);
		};

		var land = "Land";
		var water = "Water";

		// 					name,			cat,	code,	color,				symbol, moves, 	resourceProd
		this.Desert 	= t("Desert",		land,	"/", 	"rgb(255,000,128)",	"/",	1,		null);
		this.Forest		= t("Forest", 		land,	"@",	"rgb(000,255,000)",	"@",	2,		null);
		this.Glacier	= t("Glacier", 		land,	"#",	"rgb(255,255,255)",	"#",	2,		null);
		this.Grassland	= t("Grassland", 	land,	":",	"rgb(000,255,000)",	":",	1,		null);
		this.Hills		= t("Hills",		land,	"*",	"rgb(000,255,000)",	"*",	2,		null);
		this.Jungle		= t("Jungle",		land, 	"&",	"rgb(000,064,000)",	"&",	2,		null);
		this.Mountains	= t("Mountains",	land, 	"^", 	"rgb(128,128,128)",	"^",	3, 		null);
		this.Ocean 		= t("Ocean",		water,	"~",	"rgb(000,000,255)",	"~",	100,	null);
		this.Plains 	= t("Plains",		land,	".",	"rgb(000,128,000)",	".",	1,		null);
		this.River		= t("River",		land,	"S",	"rgb(000,255,032)",	"S",	1,		null);
		this.Swamp		= t("Swamp",		land,	"=",	"rgb(064,192,000)",	"=",	2,		null);
		this.Tundra		= t("Tundra",		land, 	"-",	"rgb(128,255,128)",	"-",	2,		null);

		this._All =
		[
			this.Desert,
			this.Forest,
			this.Glacier,
			this.Grassland,
			this.Hills,
			this.Jungle,
			this.Mountains,
			this.Ocean,
			this.Plains,
			this.River,
			this.Swamp,
			this.Tundra
		];
	}
}

class Owner
{
	constructor
	(
		name,
		colorName,
		incomeAllocation,
		research,
		mapKnowledge,
		bases,
		units
	)
	{
		this.name = name;
		this.colorName = colorName;
		this.incomeAllocation = incomeAllocation;
		this.research = research;
		this.mapKnowledge = mapKnowledge;
		this.bases = bases;
		this.units = units;

		this.baseSelectedName = null;
		this.unitSelectedIndex = null;
	}

	baseSelected()
	{
		var base =
		(
			this.baseSelectedName == null
			? null
			: this.bases.find(x => x.name == this.baseSelectedName)
		);

		return base;
	}

	initialize(world)
	{
		this.bases.forEach(x => x.initialize(world) );
		this.units.forEach(x => x.initialize(world) );

		this.unitSelectNextWithMoves();
	}

	turnAdvance(world)
	{
		this.bases.forEach(x => x.turnAdvance(world) );
		this.units.forEach(x => x.turnAdvance(world) );

		this.unitSelectNextWithMoves();
	}

	unitSelectById(idToSelect)
	{
		var unitToSelect = this.units.find(x => x.id == idToSelect);
		if (unitToSelect == null)
		{
			throw new Error("No unit found with ID: " + idToSelect);
		}
		else
		{
			var unitToSelectIndex = this.units.indexOf(unitToSelect);
			this.unitSelectedIndex = unitToSelect.id;
		}
	}

	unitSelectNextWithMoves()
	{
		var areThereAnyUnitsWithMoves =
			this.units.some(x => x.hasMovesThisTurn());

		if (areThereAnyUnitsWithMoves == false)
		{
			this.unitSelectedIndex = null;
		}
		else
		{
			if (this.unitSelectedIndex == null)
			{
				this.unitSelectedIndex = -1;
			}

			while (true)
			{
				this.unitSelectedIndex++;
				if (this.unitSelectedIndex >= this.units.length)
				{
					this.unitSelectedIndex = 0;
				}

				var unitSelected = this.unitSelected();
				if (unitSelected.hasMovesThisTurn())
				{
					break;
				}

			}
		}
	}

	unitSelected()
	{
		var unit =
		(
			this.unitSelectedIndex == null
			? null
			: this.units[this.unitSelectedIndex]
		);

		return unit;
	}
}

class OwnerIncomeAllocation
{
	constructor(upkeepFraction, researchFraction, luxuriesFraction)
	{
		this.upkeepFraction = upkeepFraction;
		this.researchFraction = researchFraction;
		this.luxuriesFraction = luxuriesFraction;
	}

	static default()
	{
		return new OwnerIncomeAllocation(.5, .5, 0);
	}

	isValid()
	{
		var sumOfFractions =
			this.upkeepFraction
			+ this.researchFraction
			+ this.luxuriesFraction;

		return (sumOfFractions == 1);
	}
}

class OwnerMapKnowledge
{
	constructor(cellsKnownIndices)
	{
		cellsKnownIndices = cellsKnownIndices || [];
		this.cellsKnownIndicesByIndex =
			new Map(cellsKnownIndices.map(x => [x, x]));
		this.cellsVisibleIndicesByIndex = new Map();
	}

	static default()
	{
		return new OwnerMapKnowledge(null);
	}

	draw(universe, world, owner)
	{
		var mapComplete = world.map;
		var mapSizeInCells = mapComplete.sizeInCells;
		var cellSizeInPixels = Coords.ones().multiplyScalar(16);
		var cellSizeInPixelsHalf = cellSizeInPixels.clone().half();
		var cellRadiusInPixels = cellSizeInPixelsHalf.x;
		var cellPosInCells = Coords.create();
		var cellPosInPixels = Coords.create();

		var mapSizeInPixels = mapSizeInCells.clone().multiply(cellSizeInPixels);
		var display = universe.display;
		display.drawBackground("Black");

		var cellsKnownIndices = Array.from(this.cellsKnownIndicesByIndex.keys());
		for (var c = 0; c < cellsKnownIndices.length; c++)
		{
			var cellIndex = cellsKnownIndices[c];
			cellPosInCells.overwriteWithXY
			(
				cellIndex % mapSizeInCells.x,
				Math.floor(cellIndex / mapSizeInCells.x)
			);
			var cell = mapComplete.cellAtPosInCells(cellPosInCells);
			cellPosInPixels.overwriteWith
			(
				cellPosInCells
			).multiply
			(
				cellSizeInPixels
			);

			var terrain = cell.terrain(world);
			var terrainColorName = terrain.colorName;

			display.drawRectangle
			(
				cellPosInPixels, cellSizeInPixels, terrainColorName, "Gray"
			);

			var isCellCurrentlyVisible =
				this.cellsVisibleIndicesByIndex.has(cellIndex);
			if (isCellCurrentlyVisible == false)
			{
				display.drawRectangle(cellPosInPixels, cellSizeInPixels, "rgba(0, 0, 0, 0.5)", null);
			}
		}

		var basesVisible = [];
		var unitsVisible = [];

		var cellsVisibleIndices = Array.from(this.cellsVisibleIndicesByIndex.keys());
		for (var c = 0; c < cellsVisibleIndices.length; c++)
		{
			var cellIndex = cellsVisibleIndices[c];
			cellPosInCells.overwriteWithXY
			(
				cellIndex % mapSizeInCells.x,
				Math.floor(cellIndex / mapSizeInCells.x)
			);
			var cell = mapComplete.cellAtPosInCells(cellPosInCells);
			cellPosInPixels.overwriteWith
			(
				cellPosInCells
			).multiply
			(
				cellSizeInPixels
			);

			var basePresent = cell.basePresent(world);
			if (basePresent != null)
			{
				basesVisible.push(basePresent);
			}

			var unitsPresent = cell.unitsPresent(world);
			unitsVisible.push(...unitsPresent);
		}

		var cellSizeInPixelsHalf = cellSizeInPixels.clone().half();
		var cellCenterInPixels = Coords.create();

		var baseSelected = owner.baseSelected();

		basesVisible.forEach(base =>
		{
			cellPosInPixels.overwriteWith
			(
				base.pos
			).multiply
			(
				cellSizeInPixels
			);

			cellCenterInPixels.overwriteWith
			(
				cellPosInPixels
			).add
			(
				cellSizeInPixelsHalf
			);

			var baseOwner = base.owner(world);
			var baseColorName = baseOwner.colorName;
			var isSelected = (base == baseSelected);
			var borderColor = (isSelected ? "White" : "Gray");

			display.drawRectangle
			(
				cellPosInPixels, cellSizeInPixels,
				basePresentColorName, borderColor
			);
			display.drawText
			(
				basePresent.name, cellCenterInPixels, borderColor
			);
		});

		var unitSelected = owner.unitSelected();
		unitsVisible.forEach(unit =>
		{
			cellPosInPixels.overwriteWith
			(
				unit.pos
			).multiply
			(
				cellSizeInPixels
			);

			cellCenterInPixels.overwriteWith
			(
				cellPosInPixels
			).add
			(
				cellSizeInPixelsHalf
			);

			var unitDefn = unit.defn(world);
			var unitSymbol = unitDefn.symbol;
			var unitOwner = unit.owner(world);
			var unitOwnerColorName = unitOwner.colorName;

			var isSelected = (unit == unitSelected);
			var borderColor = (isSelected ? "White" : "Gray");
			display.drawCircle
			(
				cellCenterInPixels, cellRadiusInPixels,
				unitOwnerColorName, borderColor
			);
			display.drawText(unitSymbol, cellCenterInPixels, borderColor);
		});
	}

	update(universe, world, owner)
	{
		this.cellsVisibleIndicesByIndex = new Map();

		var mapSizeInCells = world.map.sizeInCells;
		var cellOffsetPos = Coords.create();

		var ownerBases = owner.bases;

		var ownerUnits = owner.units;

		for (var i = 0; i < ownerUnits.length; i++)
		{
			var unit = ownerUnits[i];
			var unitPos = unit.pos;
			var cellsAdjacentPositions = [];
			for (var y = -1; y <= 1; y++)
			{
				cellOffsetPos.y = y;

				for (var x = -1; x <= 1; x++)
				{
					cellOffsetPos.x = x;

					var cellAdjacentPos =
						unitPos.clone().add(cellOffsetPos);
					var cellAdjacentIndex =
						cellAdjacentPos.y * mapSizeInCells.x + cellAdjacentPos.x;

					if (this.cellsKnownIndicesByIndex.has(cellAdjacentIndex) == false)
					{
						this.cellsKnownIndicesByIndex.set
						(
							cellAdjacentIndex, cellAdjacentIndex
						);
					}

					if (this.cellsVisibleIndicesByIndex.has(cellAdjacentIndex) == false)
					{
						this.cellsVisibleIndicesByIndex.set
						(
							cellAdjacentIndex, cellAdjacentIndex
						);
					}

				}
			}
		}
	}
}

class OwnerResearch
{
	constructor
	(
		technologiesKnownNames,
		technologyBeingResearchedName,
		researchStockpiled
	)
	{
		this.technologiesKnownNames = technologiesKnownNames || [];
		this.technologyBeingResearchedName = technologyBeingResearchedName;
		this.researchStockpiled = researchStockpiled || 0;
	}

	static default()
	{
		return new OwnerResearch(null, null, null);
	}
}

class ResourceProduction
{
	constructor(food, industry, trade)
	{
		this.food = food;
		this.industry = industry;
		this.trade = trade;
	}

	static create()
	{
		return new ResourceProduction(0, 0, 0);
	}

	add(other)
	{
		this.food += other.food;
		this.industry += other.industry;
		this.trade += other.trade;
	}
}

class Technology
{
	constructor
	(
		name,
		researchToLearn,
		prerequisiteNames,
		buildablesAllowedNames,
	)
	{
		this.name = name;
		this.researchToLearn = researchToLearn;
		this.prerequisiteNames = prerequisiteNames;
		this.buildablesAllowedNames = buildablesAllowedNames;
	}
}

class Technology_Instances
{
	constructor()
	{
		var t = (n, r, p, u) => { return new Technology(n, r, p, u); };

		this.AdvancedFlight		= t("Advanced Flight");
		this.Alphabet			= t("Alphabet");
		this.AmphibiousWarfare	= t("Amphibious Warfare");
		this.Astronomy			= t("Astronomy");
		this.AtomicTheory		= t("Atomic Theory");
		this.Automobile			= t("Automobile");
		this.Banking			= t("Banking");
		this.BridgeBuilding		= t("BridgeBuilding");
		this.BronzeWorking 		= t("Bronze Working");
		this.CeremonialBurial	= t("Ceremonial Burial");
		this.Chemistry			= t("Chemistry");
		this.Chivalry			= t("Chivalry");
		this.CodeOfLaws			= t("Code of Laws");
		this.CombinedArms		= t("Combined Arms");
		this.Combustion			= t("Combustion");
		this.Communism			= t("Communism");
		this.Computers			= t("Computers");
		this.Conscription		= t("Conscription");
		this.Construction		= t("Construction");
		this.Corporation		= t("Corporation");
		this.Currency 			= t("Currency");
		this.Democracy			= t("Democracy");
		this.Economics			= t("Economics");
		this.Electricity		= t("Electricity");
		this.Electronics		= t("Electronics");
		this.Engineering		= t("Engineering");
		this.Environmentalism	= t("Environmentalism");
		this.Espionage			= t("Espionage");
		this.Explosives			= t("Explosives");
		this.Feudalism			= t("Feudalism");
		this.Flight				= t("Flight");
		this.Fundamentalism		= t("Fundamentalism");
		this.FusionPower		= t("Fusion Power");
		this.GeneticEngineering	= t("Genetic Engineering");
		this.GuerrillaWarfare	= t("Guerrilla Warfare");
		this.Gunpowder 			= t("Gunpowder");
		this.HorsebackRiding 	= t("Horseback Riding");
		this.Industrialization	= t("Industrialization");
		this.Invention			= t("Invention");
		this.IronWorking		= t("IronWorking");
		this.LaborUnion			= t("Labor Union");
		this.Laser				= t("Laser");
		this.Leadership			= t("Leadership");
		this.Literacy			= t("Literacy");
		this.MachineTools		= t("Machine Tools");
		this.Magnetism			= t("Magnetism");
		this.MapMaking			= t("Map Making");
		this.Masonry			= t("Masonry");
		this.MassProduction		= t("Mass Production");
		this.Mathematics		= t("Mathematics");
		this.Medicine			= t("Medicine");
		this.Metallurgy			= t("Metallurgy");
		this.Miniaturization	= t("Miniaturization");
		this.MobileWarfare		= t("Mobile Warfare");
		this.Monarchy			= t("Monarchy");
		this.Monotheism			= t("Monotheism");
		this.Mysticism			= t("Mysticism");
		this.Navigation			= t("Navigation");
		this.NuclearFission		= t("Nuclear Fission");
		this.NuclearPower		= t("Nuclear Power");
		this.Philosophy			= t("Philosophy");
		this.Physics			= t("Physics");
		this.Plastics			= t("Plastics");
		this.Polytheism			= t("Polytheism");
		this.Pottery			= t("Pottery");
		this.Radio				= t("Radio");
		this.Railroad			= t("Railroad");
		this.Recycling			= t("Recycling");
		this.Refining			= t("Refining");
		this.Refrigeration		= t("Refrigeration");
		this.Republic			= t("Republic");
		this.Robotics			= t("Robotics");
		this.Rocketry			= t("Rocketry");
		this.Sanitization		= t("Sanitization");
		this.Seafaring			= t("Seafaring");
		this.Spaceflight		= t("Spaceflight");
		this.Stealth			= t("Stealth");
		this.SteamEngine		= t("Steam Engine");
		this.Steel				= t("Steel");
		this.Superconductors	= t("Superconductors");
		this.Tactics			= t("Tactics");
		this.Theology			= t("Theology");
		this.TheoryOfGravity	= t("TheoryOfGravity");
		this.Trade				= t("Trade");
		this.University			= t("University");
		this.WarriorCode		= t("Warrior Code");
		this.Wheels				= t("Wheels");
		this.Writing			= t("Writing");

		this._All =
		[
			this.AdvancedFlight,
			this.Alphabet,
			this.AmphibiousWarfare,
			this.Astronomy,
			this.AtomicTheory,
			this.Automobile,
			this.Banking,
			this.BridgeBuilding,
			this.BronzeWorking,
			this.CeremonialBurial,
			this.Chemistry,
			this.Chivalry,
			this.CodeOfLaws,
			this.CombinedArms,
			this.Combustion,
			this.Communism,
			this.Computers,
			this.Conscription,
			this.Construction,
			this.Corporation,
			this.Currency,
			this.Democracy,
			this.Economics,
			this.Electricity,
			this.Electronics,
			this.Engineering,
			this.Environmentalism,
			this.Espionage,
			this.Explosives,
			this.Feudalism,
			this.Flight,
			this.Fundamentalism,
			this.FusionPower,
			this.GeneticEngineering,
			this.GuerrillaWarfare,
			this.Gunpowder,
			this.HorsebackRiding,
			this.Industrialization,
			this.Invention,
			this.IronWorking,
			this.LaborUnion,
			this.Laser,
			this.Leadership,
			this.Literacy,
			this.MachineTools,
			this.Magnetism,
			this.MapMaking,
			this.Masonry,
			this.MassProduction,
			this.Mathematics,
			this.Medicine,
			this.Metallurgy,
			this.Miniaturization,
			this.MobileWarfare,
			this.Monarchy,
			this.Monotheism,
			this.Mysticism,
			this.Navigation,
			this.NuclearFission,
			this.NuclearPower,
			this.Philosophy,
			this.Physics,
			this.Plastics,
			this.Polytheism,
			this.Pottery,
			this.Radio,
			this.Railroad,
			this.Recycling,
			this.Refining,
			this.Refrigeration,
			this.Republic,
			this.Robotics,
			this.Rocketry,
			this.Sanitization,
			this.Seafaring,
			this.Spaceflight,
			this.Stealth,
			this.SteamEngine,
			this.Steel,
			this.Superconductors,
			this.Tactics,
			this.Theology,
			this.TheoryOfGravity,
			this.Trade,
			this.University,
			this.WarriorCode,
			this.Wheels,
			this.Writing
		];

		this._AllByName = new Map(this._All.map(x => [x.name, x] ) );
	}
}

class Unit
{
	constructor(ownerName, defnName, pos)
	{
		this.ownerName = ownerName;
		this.defnName = defnName;
		this.pos = pos;

		this.id = IdHelper.idNext();
		this.movesThisTurn = 0;
		this.isSleeping = false;

		this._cellToPos = Coords.create();
	}

	defn(world)
	{
		return world.defns.unitDefnByName(this.defnName);
	}

	hasMovesThisTurn()
	{
		return (this.movesThisTurn > 0);
	}

	initialize(world)
	{
		this.turnAdvance(world);
	}

	owner(world)
	{
		return world.ownerByName(this.ownerName);
	}

	toStringDetails(world)
	{
		var defn = this.defn(world);

		var lines =
		[
			"ID: " + this.id,
			"Type: " + this.defnName,
			"Position: " + this.pos.toString(),
			"Moves: " + this.movesThisTurn + "/" + defn.movement.movesPerTurn,
			defn.combat.toString()
		];
		var linesJoined = lines.join("<br />");
		return linesJoined
	}

	toStringForList()
	{
		return this.id + ": " + this.defnName + " @" + this.pos.toString();
	}

	turnAdvance(world)
	{
		var defn = this.defn(world);
		this.movesThisTurn = defn.movement.movesPerTurn;
	}

	// Movement.

	canMoveInDirection(directionToMove, world)
	{
		var costToMove =
			this.costToMoveInDirection(directionToMove, world);
		var canMove = (costToMove <= this.movesThisTurn);
		return canMove;
	}

	cellsFromAndTo(directionToMove, world)
	{
		var map = world.map;
		var cellFromPos = this.pos;
		var offsetToMove = directionToMove.offset;
		var cellToPos =
			this._cellToPos.overwriteWith(cellFromPos).add(offsetToMove);

		var cellFrom = map.cellAtPosInCells(cellFromPos);
		var cellTo = map.cellAtPosInCells(cellToPos);

		return [ cellFrom, cellTo ];
	}

	costToMoveInDirection(directionToMove, world)
	{
		var cellsFromAndTo = this.cellsFromAndTo(directionToMove, world);
		var cellFrom = cellsFromAndTo[0];
		var cellTo = cellsFromAndTo[1];

		var cellToTerrain = cellTo.terrain(world);
		var defn = this.defn(world);

		var costToMove = defn.movement.costToMoveFromCellToCell
		(
			world, cellFrom, cellTo
		);

		return costToMove;
	}

	moveInDirection(directionToMove, world)
	{
		var costToMove =
			this.costToMoveInDirection(directionToMove, world);

		if (costToMove <= this.movesThisTurn)
		{
			var cellsFromAndTo = this.cellsFromAndTo(directionToMove, world);
			var cellFrom = cellsFromAndTo[0];
			var cellTo = cellsFromAndTo[1];

			this.movesThisTurn -= costToMove;
			this.pos.overwriteWith(cellTo.pos);
			cellFrom.unitRemove(this);
			cellTo.unitAdd(this);
		}
	}
}

class UnitActivity
{
	constructor(defnName, movesInvestedSoFar)
	{
		this.defnName = defnName;
		this.movesInvestedSoFar = movesInvestedSoFar;
	}
}

class UnitActivityDefn
{
	constructor(name, movesToComplete, effect)
	{
		this.name = name;
		this.movesToComplete = movesToComplete;
		this.effect = effect;
	}
}

class UnitDefn
{
	constructor
	(
		name,
		industryToBuild,
		movement,
		combat,
		actionsAvailableNames,
		symbol
	)
	{
		this.name = name;
		this.industryToBuild = industryToBuild;
		this.movement = movement;
		this.combat = combat;
		this.actionsAvailableNames = actionsAvailableNames;
		this.symbol = symbol;
	}

	static construct
	(
		name,
		industryToBuild,
		movement,
		combat,
		actionsAvailableNames,
		symbol
	)
	{
		return new UnitDefn
		(
			name,
			industryToBuild,
			movement,
			combat,
			actionsAvailableNames,
			symbol
		);
	}

	static Instances()
	{
		if (UnitDefn._instances == null)
		{
			UnitDefn._instances = new UnitDefn_Instances();
		}
		return UnitDefn._instances;
	}
}

class UnitDefn_Instances
{
	constructor()
	{
		// Movements
		var g1 = UnitDefnMovement.ground(1);
		var g2 = UnitDefnMovement.ground(2);
		var g3 = UnitDefnMovement.ground(3);
		var o1 = UnitDefnMovement.ocean(1);
		var o3 = UnitDefnMovement.ocean(3);
		var o5 = UnitDefnMovement.ocean(5);

		var a0 = [];
		var ud = UnitDefn.construct;
		var c = UnitDefnCombat.construct; // attack, defense, integrityMax
		var udTodo =
			() =>
			{
				return new UnitDefn
				(
					"[todo]", 1000, c(0, 0, 1), UnitDefnMovement.ground(1), null, "?"
				);
			};

		// Taken from https://civilization.fandom.com/wiki/List_of_units_in_Civ2.
		// 						name,				cost,	move, 	combat, 	actns, 	symbol
		this.AegisCruiser	= udTodo();
		this.AlpineTroops	= udTodo();
		this.Archers 		= ud("Archers", 		30, 	g1,		c(3,2,1), 	a0, 	"Arc");
		this.Armor			= udTodo();
		this.Artillery		= udTodo();
		this.Battleship		= udTodo();
		this.Bomber			= udTodo();
		this.Cannon			= ud("Cannon", 			40,		g1,		c(8,1,2),	a0,		"Can");
		this.Caravan		= ud("Caravan",			50,		g1,		c(0,1,1),	a0,		"Car");
		this.Carrier		= udTodo();
		this.Catapult		= ud("Catapult",		40,		g1,		c(6,1,1),	a0,		"Cat");
		this.Cavalry		= udTodo();
		this.Chariot		= ud("Chariot",			30,		g1,		c(3,1,1),	a0, 	"Cha");
		this.CruiseMissile	= udTodo();
		this.Cruiser		= udTodo();
		this.Crusaders		= udTodo();
		this.Destroyer		= udTodo();
		this.Diplomat		= ud("Diplomat", 		30,		g1,		c(0,1,1),	a0,		"Dip");
		this.Dragoons		= udTodo();
		this.Elephants		= udTodo();
		this.Engineers		= udTodo();
		this.Explorer		= udTodo();
		this.Fanatics		= udTodo();
		this.Fighter		= udTodo();
		this.Freight		= udTodo();
		this.Frigate		= udTodo();
		this.Galleon		= udTodo();
		this.Helicopter		= udTodo();
		this.Horsemen		= udTodo();
		this.Howitzer		= udTodo();
		this.Ironclad		= udTodo();
		this.Knights		= ud("Knights", 		40, 	g2, 	c(2,1,1), 	a0,		"Kni");
		this.Legion			= ud("Legion", 			40,		g1,		c(4,2,1),	a0,		"Leg");
		this.Marines		= udTodo();
		this.MechInfantry	= udTodo();
		this.Musketeers		= udTodo();
		this.NuclearMissile	= udTodo();
		this.Paratroopers	= udTodo();
		this.Partisans		= udTodo();
		this.Phalanx		= ud("Phalanx",			20,		g1,		c(1,2,1),	a0,		"Pha");
		this.Pikemen		= ud("Pikemen",			20,		g1,		c(1,2,1),	a0,		"Pik");
		this.Riflemen		= ud("Riflemen",		40,		g1,		c(4,2,1),	a0,		"Rif");
		this.Settlers 		= ud("Settlers", 		40, 	g1, 	c(0,1,2),	a0,		"Set");
		this.Spy			= ud("Spy", 			30,		g3,		c(0,0,1),	a0,		"Spy");
		this.StealthBomber	= udTodo();
		this.StealthFighter	= udTodo();
		this.Submarine		= udTodo();
		this.Transport		= udTodo();
		this.Trireme		= ud("Trireme",			40,		o3,		c(1,1,1),	a0,		"Tri");
		this.Warriors 		= ud("Warriors", 		10, 	g1, 	c(1,1,1),	a0,		"War");

		this._All =
		[
			this.AegisCruiser,
			this.Battleship,
			this.Bomber,
			this.Cannon,
			this.Caravan,
			this.Carrier,
			this.Catapult,
			this.Cavalry,
			this.Chariot,
			this.CruiseMissile,
			this.Cruiser,
			this.Crusaders,
			this.Destroyer,
			this.Diplomat,
			this.Dragoons,
			this.Elephants,
			this.Engineers,
			this.Explorer,
			this.Fanatics,
			this.Fighter,
			this.Freight,
			this.Frigate,
			this.Galleon,
			this.Helicopter,
			this.Horsemen,
			this.Howitzer,
			this.Ironclad,
			this.Knights,
			this.Legion,
			this.Marines,
			this.MechInfantry,
			this.Musketeers,
			this.NuclearMissile,
			this.Paratroopers,
			this.Partisans,
			this.Phalanx,
			this.Pikemen,
			this.Riflemen,
			this.Settlers,
			this.Spy,
			this.StealthFighter,
			this.Submarine,
			this.Transport,
			this.Trireme,
			this.Warriors
		];
	}
}

class UnitDefnCombat
{
	constructor(attack, defense, integrityMax)
	{
		this.attack = attack;
		this.defense = defense;
		this.integrityMax = integrityMax;
	}

	static construct(attack, defense, integrityMax)
	{
		return new UnitDefnCombat(attack, defense, integrityMax);
	}

	toString()
	{
		return "Atk/Def: " + this.attack + "/" + this.defense;
	}
}

class UnitDefnMovement
{
	constructor(movesPerTurn, costToMoveFromCellToCell)
	{
		this.movesPerTurn = movesPerTurn;
		this.costToMoveFromCellToCell = costToMoveFromCellToCell;
	}

	static ground(movesPerTurn)
	{
		return new UnitDefnMovement
		(
			movesPerTurn,
			(world, cellFrom, cellTo) =>
			{
				var cellToTerrain = cellTo.terrain(world);
				var cellToTerrainIsLand = cellToTerrain.isLand();
				var costToMove =
				(
					cellToTerrainIsLand
					? cellToTerrain.movesToTraverse
					: Number.POSITIVE_INFINITY
				);
				return costToMove;
			}
		);
	}

	static ocean(movesPerTurn)
	{
		return new UnitDefnMovement
		(
			movesPerTurn,
			(world, cellFrom, cellTo) =>
			{
				var cellToTerrain = cellTo.terrain(world);
				var cellToTerrainIsOcean = (cellToTerrain.name == "Ocean");
				var costToMove = (cellToTerrainIsOcean ? 1 : Number.POSITIVE_INFINITY);
				return costToMove;
			}
		);
	}

}

class Universe
{
	constructor(display, world)
	{
		this.display = display;
		this.world = world;

		this.inputHelper = new InputHelper();
		this.outputLog = new DisplayText("textareaOutputLog");
	}

	initialize()
	{
		this.inputHelper.initialize(this);
		this.display.initialize(this);
		this.world.initialize(this);
	}
}

class World
{
	constructor(name, defns, turnsSoFar, map, owners)
	{
		this.name = name;
		this.defns = defns;
		this.turnsSoFar = turnsSoFar;
		this.map = map;
		this.owners = owners;

		this.bases = [];
		this.units = [];

		for (var i = 0; i < this.owners.length; i++)
		{
			var owner = this.owners[i];
			owner.bases.forEach(x => this.baseAdd(x));
			owner.units.forEach(x => this.unitAdd(x));
		}

		this.ownerCurrentIndex = 0;
	}

	static demo()
	{
		var terrains = MapOfCellsCellTerrain.Instances()._All;

		var unitDefns = UnitDefn.Instances()._All;

		var defns = new WorldDefns
		(
			terrains,
			unitDefns
		);

		var map = MapOfCells.fromCellsAsStrings
		([
			//       10        20        30        40        5         60
			//234567890123456789012345678901234567890123456789012345678901234
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~", // 10
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~", // 20
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~",
			"~~............................~~..............................~~", // 30
			"~~............................~~..............................~~",
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
		]);

		var owners = [];
		var ownerCount = 2;
		var ownerColorNames = [ "Blue", "Green" ];

		for (var i = 0; i < ownerCount; i++)
		{
			var ownerName = "Owner" + i;
			var ownerColorName = ownerColorNames[i];

			var posRandom = Coords.random().multiply(map.sizeInCells).floor();
			var unitInitial = new Unit
			(
				ownerName,
				"Settlers",
				posRandom
			);

			var owner = new Owner
			(
				ownerName,
				ownerColorName,
				OwnerIncomeAllocation.default(), // incomeAllocation,
				OwnerResearch.default(),
				OwnerMapKnowledge.default(),
				[], // bases
				[
					unitInitial
				]
			);

			owners.push(owner);
		}

		var worldDemo = new World
		(
			"Demo World:",
			defns,
			0, // turnsSoFar
			map,
			owners
		);

		return worldDemo;
	}

	baseAdd(base)
	{
		this.bases.push(base);
		var cell = this.map.cellAtPosInCells(base.pos);
		cell.baseAdd(cell);
	}

	baseByName(name)
	{
		return this.bases.find(x => x.name == name);
	}

	draw(universe)
	{
		var display = universe.display;
		var ownerCurrent = this.ownerCurrent();
		var ownerCurrentMapKnowledge = ownerCurrent.mapKnowledge;
		ownerCurrentMapKnowledge.update(universe, this, ownerCurrent);
		ownerCurrentMapKnowledge.draw(universe, this, ownerCurrent);
	}

	initialize(universe)
	{
		this.owners.forEach(x => x.initialize(this));

		this.draw(universe);
	}

	ownerByName(name)
	{
		return this.owners.find(x => x.name == name);
	}

	ownerCurrent()
	{
		return this.owners[this.ownerCurrentIndex];
	}

	ownerCurrentAdvance()
	{
		this.ownerCurrentIndex++;
		if (this.ownerCurrentIndex >= this.owners.length)
		{
			this.turnAdvance();
		}

		return this.ownerCurrent();
	}

	turnAdvance()
	{
		this.owners.forEach(x => x.turnAdvance(this) );
		this.turnsSoFar++;
	}

	unitAdd(unit)
	{
		this.units.push(unit);
		var cell = this.map.cellAtPosInCells(unit.pos);
		cell.unitAdd(unit);
	}

	unitById(id)
	{
		return this.units.find(x => x.id == id);
	}
}

class WorldDefns
{
	constructor(terrains, unitDefns)
	{
		this.terrains = terrains;
		this.unitDefns = unitDefns;

		this._terrainsByCode = new Map(this.terrains.map(x => [x.code, x]));
		this._unitDefnsByName = new Map(this.unitDefns.map(x => [x.name, x]));
	}

	terrainByCode(code)
	{
		return this._terrainsByCode.get(code);
	}

	unitDefnByName(name)
	{
		return this._unitDefnsByName.get(name);
	}
}

// Run.

new Game().run();

</script>

</body>
</html>