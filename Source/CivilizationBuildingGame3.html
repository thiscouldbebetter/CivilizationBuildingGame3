<html>
<body>

<div id="divUi">

	<h3>Civilization-Building Game</h3>

	<p>
		Enter valid commands to play the game.  Enter "help" for a list of commands.
	</p>

	<div>
		<label>Display:</label>
		<br />
		<div id="textareaDisplay" style="font:10px Courier New" readonly="readonly"></div>
	</div>

	<div>
		<label>Output:</label>
		<br />
		<textarea id="textareaOutputLog" cols="80" rows="8" readonly="readonly"></textarea>
	</div>

	<div>
		<label>Command:</label>
		<br />
		<input id="inputCommand" readonly="readonly"></input>
	</div>

</div>

<script type="text/javascript">

class Game
{
	run()
	{
		var display = new Display("textareaDisplay");
		var world = World.demo();
		var universe = new Universe(display, world);
		universe.initialize();
	}
}

// Classes.

class Base
{
	constructor
	(
		name,
		pos,
		ownerName,
		population,
		landUsage,
		foodStockpiled,
		industry
	)
	{
		this.name = name;
		this.pos = pos;
		this.ownerName = ownerName;
		this.population = population;
		this.landUsage = landUsage;
		this.foodStockpiled = foodStockpiled;
		this.industry = industry;
	}

	turnUpdate(universe, world)
	{
		// todo
	}
}

class BaseImprovementDefn
{
	constructor(name, effect)
	{
		this.name = name;
		this.effect = effect;
	}
}

class BaseIndustry
{
	constructor(buildableInProgressName, industryStockpiled)
	{
		this.buildableInProgressName = buildableInProgressName;
		this.industryStockpiled = industryStockpiled;
	}
}

class BaseLandUsage
{
	constructor(offsetsInUse)
	{
		this.offsetsInUse = offsetsInUse;
	}
}

class Color
{
	constructor(name, systemColor)
	{
		this.name = name;
		this.systemColor = systemColor;
	}
}

class Command
{
	constructor(opcode, operands)
	{
		this.opcode = opcode;
		this.operands = operands;
	}

	static fromText(commandText)
	{
		var commandParsed = null;

		var opcode = CommandOpcode.fromCommandText(commandText);

		if (opcode != null)
		{
			var commandTextMinusOpcode = commandText.substr(opcode.text.length);
			var operands = commandTextMinusOpcode.split(" ").filter(x => x != "");

			commandParsed = new Command(opcode, operands);
		}

		return commandParsed;
	}

	execute(universe, world)
	{
		this.opcode.execute(universe, world);
	}
}

class CommandOpcode
{
	constructor(text, execute)
	{
		this.text = text;
		this.execute = execute;
	}

	static Instances()
	{
		if (CommandOpcode._instances == null)
		{
			CommandOpcode._instances = new CommandOpcode_Instances();
		}
		return CommandOpcode._instances;
	}

	static fromCommandText(commandText)
	{
		var opcode = CommandOpcode.Instances().byCommandText(commandText);
		return opcode;
	}
}

class CommandOpcode_Instances
{
	constructor()
	{
		var co = (text, execute) => new CommandOpcode(text, execute);

		var executeTodo = () => alert("todo");

		this.CityBuild = co("build", executeTodo);
		this.CityList = co("list cities", executeTodo);
		this.CitySelect = co("select city", executeTodo);
		this.CityShow = co("show city", executeTodo);
		this.CityUseLandAtOffset = co("use offset", executeTodo);

		this.CivList = co("list civilizations", executeTodo);
		this.CivSelect = co("select civilzation", executeTodo);
		this.CivShow = co("show civilization", executeTodo);

		this.CivOfferAccept = co("accept offer", executeTodo);
		this.CivOfferDecline = co("decline offer", executeTodo);
		this.CivOfferAlliance = co("alliance", executeTodo);
		this.CivOfferList = co("list offers", executeTodo);
		this.CivOfferPeace = co("peace", executeTodo);
		this.CivOfferTrade = co("trade", executeTodo);
		this.CivOfferWar = co("war", executeTodo);

		this.Help = co("help", executeTodo);

		this.TechShow = co("show research", executeTodo);
		this.TechList = co("list technologies", executeTodo);
		this.TechResearch = co("research", executeTodo);

		this.TurnEnd = co("end turn", executeTodo);

		this.UnitDisband = co("disband", executeTodo);
		this.UnitFortify = co("fortify", executeTodo);
		this.UnitList = co("list unit", executeTodo);
		this.UnitMove = co("move", executeTodo);
		this.UnitPass = co("pass", executeTodo);
		this.UnitSelect = co("select unit", executeTodo);
		this.UnitSleep = co("sleep", executeTodo);
		this.UnitSupport = co("support", executeTodo);

		this.UnitSettlerIrrigate = co("irrigate", executeTodo);
		this.UnitSettlerMine = co("mine", executeTodo);
		this.UnitSettlerRoad = co("road", executeTodo); 
		this.UnitSettlerSettle = co("settle", executeTodo);

		this.WorldShow = co
		(
			"show world",
			(u, w) =>
			{
				w.draw(u, w);
			}
		);

		this._All =
		[
			this.CityBuild,
			this.CityList,
			this.CitySelect,
			this.CityShow,
			this.CityUseLandAtOffset,

			this.CivOfferAccept,
			this.CivOfferDecline,
			this.CivOfferAlliance,
			this.CivOfferList,
			this.CivOfferPeace,
			this.CivOfferTrade,
			this.CivOfferWar,

			this.Help,

			this.TechShow,
			this.TechList,
			this.TechResearch,

			this.TurnEnd,

			this.UnitDisband,
			this.UnitFortify,
			this.UnitList,
			this.UnitMove,
			this.UnitPass,
			this.UnitSelect,
			this.UnitSleep,
			this.UnitSupport,

			this.UnitSettlerIrrigate,
			this.UnitSettlerMine,
			this.UnitSettlerRoad,
			this.UnitSettlerSettle,

			this.WorldShow,
		];
	}

	byCommandText(commandText)
	{
		var opcodeFound =
			this._All.find(x => commandText.startsWith(x.text));
		return opcodeFound;
	}
}

class Coords
{
	constructor(x, y)
	{
		this.x = x;
		this.y = y;
	}

	static create()
	{
		return new Coords(0, 0);
	}

	static random()
	{
		return Coords.create().randomize();
	}

	clone()
	{
		return new Coords(this.x, this.y);
	}

	floor()
	{
		this.x = Math.floor(this.x);
		this.y = Math.floor(this.y);
		return this;
	}

	multiply(other)
	{
		this.x *= other.x;
		this.y *= other.y;
		return this;
	}

	randomize()
	{
		this.x = Math.random();
		this.y = Math.random();
		return this;
	}
}

class Display
{
	constructor(domElementId)
	{
		this.domElementId = domElementId;
	}

	clear()
	{
		var d = document;
		var textareaDisplay = d.getElementById(this.domElementId);
		textareaDisplay.innerHTML = "";
	}

	writeLine(lineToWrite)
	{
		this.writeString(lineToWrite);
		this.writeNewline();
	}

	writeNewline()
	{
		this.writeString("<br />");
	}

	writeString(stringToWrite, colorName)
	{
		var d = document;
		var textareaDisplay = d.getElementById(this.domElementId);
		if (colorName != null)
		{
			stringToWrite = "<mark style='background-color:" + colorName + "'>" + stringToWrite + "</mark>";
		}
		textareaDisplay.innerHTML += stringToWrite;
	}
}

class IdHelper
{
	static _idNext = 0;

	static idNext()
	{
		var id = this._idNext;
		this._idNext++;
		return id;
	}
}

class InputHelper
{
	initialize(universe)
	{
		var d = document;

		var body = d.body;
		body.onkeydown = this.keyDown.bind(this, universe);

		var inputCommand = d.getElementById("inputCommand");
		inputCommand.focus();

		return this;
	}

	keyDown(universe, event)
	{
		event.preventDefault();

		var key = event.key;

		var d = document;
		var inputCommand = d.getElementById("inputCommand");

		if (key == "Enter")
		{
			var commandText = inputCommand.value;

			inputCommand.value = "";
			inputCommand.focus();

			var command = Command.fromText(commandText);
			if (command == null)
			{
				universe.outputLog.messageSet("Unrecognized command: " + commandText);
			}
			else
			{
				command.execute(universe, universe.world);
			}
		}
		else if (key == "Backspace")
		{
			inputCommand.value = inputCommand.value.substr(0, inputCommand.value.length - 1);
		}
		else if (key.length == 1)
		{
			inputCommand.value += key;
		}
	}
}

class OutputLog
{
	constructor(domElementId)
	{
		this.domElementId = domElementId;
	}

	draw()
	{
		var d = document;
		var domElement = d.getElementById(this.domElementId);
		domElement.value = this.message;
	}

	initialize()
	{
		this.message = "[No output yet.]"
		this.draw();
	}

	messageSet(value)
	{
		this.message = value;
		this.draw();
	}
}

class MapOfCells
{
	constructor(sizeInCells, cells)
	{
		this.sizeInCells = sizeInCells;
		this.cells = cells;
	}

	static fromCellsAsStrings(cellsAsStrings)
	{
		var sizeInCells = new Coords
		(
			cellsAsStrings[0].length, cellsAsStrings.length
		);
		var cells = [];

		var cellPosInCells = Coords.create();

		for (var y = 0; y < sizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < sizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cellAsString = cellsAsStrings[y][x];
				var cellTerrainCode = cellAsString;

				var cell = new MapOfCellsCell
				(
					cellTerrainCode
				);

				cells.push(cell);
			}
		}

		var map = new MapOfCells(sizeInCells, cells);

		return map;
	}

	cellAtPos(posInCells)
	{
		return this.cells[this.cellIndexAtPos(posInCells)];
	}

	cellIndexAtPos(posInCells)
	{
		return posInCells.y * this.sizeInCells.x + posInCells.x;
	}

	draw(universe, world)
	{
		var display = universe.display;
		var cellPosInCells = Coords.create();

		for (var y = 0; y < this.sizeInCells.y; y++)
		{
			cellPosInCells.y = y;

			for (var x = 0; x < this.sizeInCells.x; x++)
			{
				cellPosInCells.x = x;

				var cell = this.cellAtPos(cellPosInCells);
				var cellTerrain = cell.terrain(world);
				var cellTerrainSymbol = cellTerrain.symbol;
				var cellTerrainColorName = cellTerrain.colorName;

				var cellAsString = cellTerrainSymbol;

				display.writeString(cellTerrainSymbol, cellTerrainColorName);
			}

			display.writeNewline();
		}
	}
}

class MapOfCellsCell
{
	constructor
	(
		terrainCode,
		basesPresentNames,
		improvementsPresentNames,
		unitsPresentIds
	)
	{
		this.terrainCode = terrainCode;
		this.basesPresentNames = basesPresentNames || [];
		this.improvementsPresentNames = improvementsPresentNames || [];
		this.unitsPresentIds = unitsPresentIds || [];
	}

	baseAdd(base)
	{
		this.basesPresentNames.push(base.name);
	}

	terrain(world)
	{
		return world.defns.terrainByCode(this.terrainCode);
	}

	unitAdd(unit)
	{
		this.unitsPresentIds.push(unit.id);
	}
}

class MapOfCellsCellImprovement
{
	constructor(name, effect)
	{
		this.name = name;
		this.effect = effect;
	}
}

class MapOfCellsCellTerrain
{
	constructor
	(
		name,
		code,
		colorName,
		symbol,
		movesToTraverse,
		resourceProductionPerTurn
	)
	{
		this.name = name;
		this.code = code;
		this.colorName = colorName;
		this.symbol = symbol;
		this.movesToTraverse = movesToTraverse;
		this.resourceProductionPerTurn = resourceProductionPerTurn;
	}
}

class Owner
{
	constructor
	(
		name,
		colorName,
		incomeAllocation,
		research,
		mapKnowledge,
		bases,
		units
	)
	{
		this.name = name;
		this.colorName = colorName;
		this.incomeAllocation = incomeAllocation;
		this.research = research;
		this.mapKnowledge = mapKnowledge;
		this.bases = bases;
		this.units = units;
	}
}

class OwnerIncomeAllocation
{
	constructor(upkeepFraction, researchFraction, luxuriesFraction)
	{
		this.upkeepFraction = upkeepFraction;
		this.researchFraction = researchFraction;
		this.luxuriesFraction = luxuriesFraction;
	}

	static default()
	{
		return new OwnerIncomeAllocation(.5, .5, 0);
	}

	isValid()
	{
		var sumOfFractions =
			this.upkeepFraction
			+ this.researchFraction
			+ this.luxuriesFraction;

		return (sumOfFractions == 1);
	}
}

class OwnerMapKnowledge
{
	constructor(cellsKnownIndices)
	{
		this.cellsKnownIndices = cellsKnownIndices || [];
	}

	static default()
	{
		return new OwnerMapKnowledge(null);
	}

	mapKnownFromMapComplete(mapComplete)
	{
		return mapComplete; // todo
	}
}

class OwnerResearch
{
	constructor
	(
		technologiesKnownNames,
		technologyBeingResearchedName,
		researchStockpiled
	)
	{
		this.technologiesKnownNames = technologiesKnownNames || [];
		this.technologyBeingResearchedName = technologyBeingResearchedName;
		this.researchStockpiled = researchStockpiled || 0;
	}

	static default()
	{
		return new OwnerResearch(null, null, null);
	}
}

class ResourceProduction
{
	constructor(food, industry, trade)
	{
		this.food = food;
		this.industry = industry;
		this.trade = trade;
	}
}

class Technology
{
	constructor
	(
		name,
		researchToLearn,
		prerequisiteNames,
		unitDefnsAllowedNames
	)
	{
		this.name = name;
		this.researchToLearn = researchToLearn;
		this.prerequisiteNames = prerequisiteNames;
		this.unitDefnsAllowedNames = unitDefnsAllowedNames;
	}
}

class Unit
{
	constructor(ownerName, defnName, pos)
	{
		this.ownerName = ownerName;
		this.defnName = defnName;
		this.pos = pos;

		this.id = IdHelper.idNext();
		this.isSleeping = false;
	}

	defn(world)
	{
		return world.defns.unitDefnByName(this.defnName);
	}

	move(world, directionToMove)
	{
		var map = world.map;
		var cellFromPos = this.pos;
		var cellToPos = cellPos.add(directionToMove);

		var cellFrom = map.cellAtPos(cellPosNext);
		var cellTo = map.cellAtPos(cellPosNext);

		var cellNextTerrain = cellNext.terrain(world);
		var defn = this.defn(world);

		var costToMove = defn.costToMoveFromCellToCell
		(
			world, cellFrom, cellTo
		);

		if (costToMove <= this.movesThisTurn)
		{
			this.movesThisTurn -= costToMove;
			this.pos.overwriteWith(cellToPos);
		}
	}

	turnUpdate()
	{
		var defn = this.defn();
		this.movesThisTurn = defn.movesPerTurn;
	}
}

class UnitActivity
{
	constructor(defnName, movesInvestedSoFar)
	{
		this.defnName = defnName;
		this.movesInvestedSoFar = movesInvestedSoFar;
	}
}

class UnitActivityDefn
{
	constructor(name, movesToComplete, effect)
	{
		this.name = name;
		this.movesToComplete = movesToComplete;
		this.effect = effect;
	}
}

class UnitDefn
{
	constructor
	(
		name,
		industryToBuild,
		attack,
		defense,
		movement,
		activityDefnsAvailableNames
	)
	{
		this.name = name;
		this.industryToBuild = industryToBuild;
		this.attack = attack;
		this.defense = defense;
		this.movement = movement;
		this.activityDefnsAvailableNames = activityDefnsAvailableNames;
	}
}

class UnitDefnMovement
{
	constructor(movesPerTurn, costToMoveFromCellToCell)
	{
		this.movesPerTurn = movesPerTurn;
		this.costToMoveFromCellToCell = costToMoveFromCellToCell;
	}

	static ground1()
	{
		return new UnitDefnMovement
		(
			1, // movesPerTurn
			(universe, world, cellFrom, cellTo) =>
			{
				var cellToTerrain = cellTo.terrain(world);
				var cellToTerrainIsGround = cellToTerrain.isGround();
				var costToMove =
				(
					cellToTerrainIsGround
					? cellTerrain.movesToTraverse
					: Number.POSITIVE_INFINITY
				);
				return costToMove;
			}
		);
	}

	static ocean1()
	{
		return new UnitDefnMovement
		(
			1, // movesPerTurn
			(universe, world, cellFrom, cellTo) =>
			{
				var cellToTerrain = cellTo.terrain(world);
				var cellToTerrainIsGround = cellToTerrain.name == "Ocean";
				var costToMove = (cellToTerrainIsGround ? 1 : Number.POSITIVE_INFINITY);
				return costToMove;
			}
		);
	}

}

class Universe
{
	constructor(display, world)
	{
		this.display = display;
		this.world = world;

		this.inputHelper = new InputHelper();
		this.outputLog = new OutputLog("textareaOutputLog");
	}

	initialize()
	{
		this.inputHelper.initialize(this);
		this.outputLog.initialize();
	}
}

class World
{
	constructor(name, defns, turnsSoFar, map, owners)
	{
		this.name = name;
		this.defns = defns;
		this.turnsSoFar = turnsSoFar;
		this.map = map;
		this.owners = owners;

		this.bases = [];
		this.units = [];

		for (var i = 0; i < this.owners.length; i++)
		{
			var owner = this.owners[i];
			owner.bases.forEach(x => this.baseAdd(x));
			owner.units.forEach(x => this.unitAdd(x));
		}
	}

	static demo()
	{
		var terrains =
		[
			new MapOfCellsCellTerrain
			(
				"Ocean",
				"~", // code,
				"Blue", // colorName,
				"~", // symbol,
				100, // movesToTraverse,
				null // resourceProductionPerTurn
			),

			new MapOfCellsCellTerrain
			(
				"Plain",
				".", // code,
				"Green", // colorName,
				".", // symbol,
				1, // movesToTraverse,
				null // resourceProductionPerTurn
			),
		];

		var unitDefns =
		[
			new UnitDefn
			(
				"Settlers",
				50, // industryToBuild,
				0, // attack,
				1, // defense,
				UnitDefnMovement.ground1(),
				null // activityDefnsAvailableNames
			)
		];

		var defns = new WorldDefns
		(
			terrains,
			unitDefns
		);

		var map = MapOfCells.fromCellsAsStrings
		([
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~..............................~",
			"~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~",
		]);

		var owners = [];
		var ownerCount = 2;
		var ownerColorNames = [ "Blue", "Green" ];

		for (var i = 0; i < ownerCount; i++)
		{
			var ownerName = "Owner" + i;
			var ownerColorName = ownerColorNames[i];

			var posRandom = Coords.random().multiply(map.sizeInCells).floor();
			var unitInitial = new Unit
			(
				ownerName,
				"Settler",
				posRandom
			);

			var owner = new Owner
			(
				ownerName,
				ownerColorName,
				OwnerIncomeAllocation.default(), // incomeAllocation,
				OwnerResearch.default(),
				OwnerMapKnowledge.default(),
				[], // bases
				[
					unitInitial
				]
			);

			owners.push(owner);
		}

		var worldDemo = new World
		(
			"Demo World:",
			defns,
			0, // turnsSoFar
			map,
			owners
		);

		return worldDemo;
	}

	draw(universe, world)
	{
		var display = universe.display;
		display.writeLine(this.name);
		this.map.draw(universe, world);
		display.writeNewline();
	}

	baseAdd(base)
	{
		this.bases.push(base);
		var cell = this.map.cellAtPos(base.pos);
		cell.baseAdd(cell);
	}

	ownerByName(name)
	{
		return this.owners.find(x => x.name == name);
	}

	unitAdd(unit)
	{
		this.units.push(unit);
		var cell = this.map.cellAtPos(unit.pos);
		cell.unitAdd(unit);
	}

	unitById(id)
	{
		return this.units.find(x => x.id == id);
	}
}

class WorldDefns
{
	constructor(terrains, unitDefns)
	{
		this.terrains = terrains;
		this.unitDefns = unitDefns;

		this._terrainsByCode = new Map(this.terrains.map(x => [x.code, x]));
		this._unitDefnsByName = new Map(this.unitDefns.map(x => [x.name, x]));
	}

	terrainByCode(code)
	{
		return this._terrainsByCode.get(code);
	}

	unitDefnByName(name)
	{
		return this._unitDefnsByName.get(name);
	}
}

// Run.

new Game().run();

</script>

</body>
</html>